{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/engine/types.ts", "../library/src/utils/text.ts", "../library/src/plugins/core/attributes/computed.ts", "../library/src/engine/signals.ts", "../library/src/plugins/core/attributes/signals.ts", "../library/src/utils/dom.ts", "../library/src/engine/errors.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/plugins/framework/backend/shared.ts", "../library/src/plugins/framework/backend/actions/sse.ts", "../library/src/plugins/framework/backend/actions/delete.ts", "../library/src/plugins/framework/backend/actions/get.ts", "../library/src/plugins/framework/backend/actions/patch.ts", "../library/src/plugins/framework/backend/actions/post.ts", "../library/src/plugins/framework/backend/actions/put.ts", "../library/src/plugins/framework/backend/watchers/executeScript.ts", "../library/src/utils/view-transtions.ts", "../library/src/plugins/framework/backend/watchers/mergeFragments.ts", "../library/src/plugins/framework/backend/watchers/mergeSignals.ts", "../library/src/plugins/framework/backend/watchers/removeFragments.ts", "../library/src/plugins/framework/backend/watchers/removeSignals.ts", "../library/src/plugins/framework/attributes/attr.ts", "../library/src/plugins/framework/attributes/bind.ts", "../library/src/plugins/framework/attributes/class.ts", "../library/src/plugins/framework/attributes/indicator.ts", "../library/src/plugins/framework/attributes/jsonSignals.ts", "../library/src/utils/tags.ts", "../library/src/utils/timing.ts", "../library/src/plugins/framework/attributes/on.ts", "../library/src/plugins/framework/attributes/onIntersect.ts", "../library/src/plugins/framework/attributes/onInterval.ts", "../library/src/plugins/framework/attributes/onLoad.ts", "../library/src/utils/paths.ts", "../library/src/plugins/framework/attributes/onSignalChange.ts", "../library/src/plugins/framework/attributes/ref.ts", "../library/src/plugins/framework/attributes/show.ts", "../library/src/plugins/framework/attributes/text.ts", "../library/src/plugins/framework/actions/setAll.ts", "../library/src/plugins/framework/actions/toggleAll.ts", "../library/src/bundles/datastar.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n// The default attributes for <script/> element use when executing scripts. It is a set of key-value pairs delimited by a newline \\\\n character.\nexport const DefaultExecuteScriptAttributes = \"type module\";\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should fragments be merged using the ViewTransition API?\nexport const DefaultFragmentsUseViewTransitions = false;\n\n// Should a given set of signals merge if they are missing?\nexport const DefaultMergeSignalsOnlyIfMissing = false;\n\n// Should script element remove itself after execution?\nexport const DefaultExecuteScriptAutoRemove = true;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a fragment is merged into the DOM.\n// Morphs the fragment into the existing element.\nexport const FragmentMergeModeMorph = \"morph\"\n// Replaces the inner HTML of the existing element.\nexport const FragmentMergeModeInner = \"inner\"\n// Replaces the outer HTML of the existing element.\nexport const FragmentMergeModeOuter = \"outer\"\n// Prepends the fragment to the existing element.\nexport const FragmentMergeModePrepend = \"prepend\"\n// Appends the fragment to the existing element.\nexport const FragmentMergeModeAppend = \"append\"\n// Inserts the fragment before the existing element.\nexport const FragmentMergeModeBefore = \"before\"\n// Inserts the fragment after the existing element.\nexport const FragmentMergeModeAfter = \"after\"\n// Upserts the attributes of the existing element.\nexport const FragmentMergeModeUpsertAttributes = \"upsertAttributes\"\n\n// Default value for FragmentMergeMode\nexport const DefaultFragmentMergeMode = FragmentMergeModeMorph;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\n// An event for merging HTML fragments into the DOM.\nexport const EventTypeMergeFragments = \"datastar-merge-fragments\"\n// An event for merging signals.\nexport const EventTypeMergeSignals = \"datastar-merge-signals\"\n// An event for removing HTML fragments from the DOM.\nexport const EventTypeRemoveFragments = \"datastar-remove-fragments\"\n// An event for removing signals.\nexport const EventTypeRemoveSignals = \"datastar-remove-signals\"\n// An event for executing <script/> elements in the browser.\nexport const EventTypeExecuteScript = \"datastar-execute-script\"\n// #endregion\n\n// #endregion", "import { DATASTAR } from './consts'\nimport type { Computed, Signal } from './signals'\n\nexport enum PluginType {\n  Attribute = 1,\n  Watcher = 2,\n  Action = 3,\n}\n\nexport enum Requirement {\n  Allowed = 0,\n  Must = 1,\n  Denied = 2,\n  Exclusive = 3,\n}\n\nexport type Dependency<T = unknown> = Signal<T> | Computed<T>\nexport type OnRemovalFn = () => void\n\nexport type DatastarPlugin = AttributePlugin | WatcherPlugin | ActionPlugin\n\nexport interface DatastarSignalEvent {\n  added: Array<string>\n  removed: Array<string>\n  updated: Array<string>\n}\nexport const DATASTAR_SIGNAL_EVENT = `${DATASTAR}-signal-change`\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_EVENT]: CustomEvent<DatastarSignalEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accesible via a `data-${name}` attribute on an element\nexport type AttributePlugin = {\n  type: PluginType.Attribute\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the DastaStar instance\nexport type WatcherPlugin = {\n  type: PluginType.Watcher\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport type ActionPlugin = {\n  type: PluginType.Action\n  name: string // The name of the plugin\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n\nexport type InitContext = {\n  plugin: DatastarPlugin\n  actions: Readonly<ActionPlugins>\n  removals: Map<HTMLOrSVGElement, Map<string, OnRemovalFn>>\n  applyToElement: (el: HTMLOrSVGElement) => void\n  batch<T>(fn: () => T): T // batches signal updates (additions, removals, updates)\n  signal<T>(value: T, path?: string): Signal<T> // creates a signal\n  computed<T>(\n    deps: Dependency[],\n    fn: (...args: any[]) => T,\n    path?: string,\n  ): Computed<T> // creates a computed signal\n  effect(deps: Dependency[], fn: (...args: any[]) => void): OnRemovalFn // creates an effect\n}\n\nexport type HTMLOrSVGElement = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\nexport type GenerateReactiveExpressionFn = () => {\n  deps: Dependency[]\n  dm: boolean[] // dependency mutable flags\n  rxFn: <T>(...argsThenDeps: any[]) => T // a reactive expression\n}\n\nexport type RuntimeContext = InitContext & {\n  plugin: DatastarPlugin // The name of the plugin\n  el: HTMLOrSVGElement // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the modifiers and their tags\n  genRX: GenerateReactiveExpressionFn // function to generate a reactive expression\n  evalRX<T>(\n    rxFn: (...argsThenDeps: any[]) => T,\n    dm: boolean[],\n    deps: Dependency[],\n    ...args: any[]\n  ): T // evaluates a reactive expression\n  fnContent?: string // the content of the function\n  evt?: Event // the event that triggered the plugin\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n\nexport type EventCallbackHandler = (...args: any[]) => void\n", "import type { Modifiers } from '../engine/types'\n\nexport const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebab = (str: string) =>\n  str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .toLowerCase()\n\nexport const camel = (str: string) =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string) => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string) =>\n  camel(str).replace(/^./, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) =>\n  Function(`return Object.assign({}, ${raw})`)()\n\nexport const trimDollarSignPrefix = (str: string) =>\n  str.startsWith('$') ? str.slice(1) : str\n\nconst caseFns: Record<string, (s: string) => string> = { kebab, snake, pascal }\n\nexport function modifyCasing(str: string, mods: Modifiers) {\n  for (const c of mods.get('case') || []) {\n    const fn = caseFns[c]\n    if (fn) str = fn(str)\n  }\n  return str\n}\n", "import {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../engine/types'\nimport { modifyCasing } from '../../../utils/text'\n\nconst name = 'computed'\nexport const Computed: AttributePlugin = {\n  type: PluginType.Attribute,\n  name,\n  keyReq: Requirement.Must,\n  valReq: Requirement.Must,\n  onLoad: ({ key, mods, genRX, computed, batch }) => {\n    key = modifyCasing(key, mods)\n    const { deps, rxFn } = genRX()\n    batch(() => {\n      computed(deps, rxFn, key)\n    })\n  },\n}\n", "import {\n  DATASTAR_SIGNAL_EVENT,\n  type OnRemovalFn,\n  type DatastarSignalEvent,\n  type Dependency,\n} from './types'\n\n// const from = 'namespacedSignals'\n\nconst added = new Set<string>()\nconst removed = new Set<string>()\nconst updated = new Set<string>()\n\nexport function batch<T>(fn: () => T): T {\n  added.clear()\n  removed.clear()\n  updated.clear()\n\n  const result = fn()\n\n  if (added.size || removed.size || updated.size) {\n    document.dispatchEvent(\n      new CustomEvent<DatastarSignalEvent>(DATASTAR_SIGNAL_EVENT, {\n        detail: {\n          added: [...added],\n          removed: [...removed],\n          updated: [...updated],\n        },\n      }),\n    )\n  }\n\n  return result\n}\n\n// sorted by path\nconst dependencyPaths: string[] = []\nconst dependencies = new Map<string, Dependency>()\n\nexport function depPaths(): readonly string[] {\n  return dependencyPaths\n}\n\nexport function dep(path: string): Dependency | undefined {\n  return dependencies.get(path)\n}\n\nfunction depRange(prefix: string) {\n  const results: string[] = []\n  // binary search for the range of paths that start with prefix\n  let left = 0\n  let right = dependencyPaths.length - 1\n  const predicate = (s: string) => s !== prefix && !s.startsWith(`${prefix}.`)\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2)\n    const midPath = dependencyPaths[mid]\n    if (midPath < prefix) {\n      left = mid + 1\n    } else if (midPath > prefix) {\n      right = mid - 1\n    } else {\n      // found the prefix, now find the range\n      let start = mid\n\n      do {\n        const s = dependencyPaths[start]\n        if (predicate(s)) break\n        start--\n      } while (start >= 0)\n\n      let end = mid\n      do {\n        const s = dependencyPaths[end]\n        if (predicate(s)) break\n        end++\n      } while (end < dependencyPaths.length)\n      for (let i = start + 1; i < end; i++) {\n        results.push(dependencyPaths[i])\n      }\n      return results\n    }\n  }\n\n  return results\n}\n\nexport function setDep(path: string, dep: Dependency) {\n  removeDeps(path)\n  dependencyPaths.push(path)\n  dependencies.set(path, dep)\n  dependencyPaths.sort() // keep paths sorted\n  added.add(path)\n}\n\nexport function setDepValue<T>(path: string, value: T) {\n  const existingSignal = dependencies.get(path)\n  if (existingSignal) {\n    if (!(existingSignal instanceof Signal)) {\n      return\n    }\n\n    existingSignal.value = value\n  } else {\n    signal(value, path)\n  }\n}\n\nexport function depValue<T>(path: string) {\n  return dependencies.get(path)?.value as T | undefined\n}\n\nexport function upsertIfMissing<T>(path: string, defaultValue: T) {\n  let inserted = false\n  let dep = dependencies.get(path)\n  if (!dep) {\n    inserted = true\n    dep = signal(defaultValue, path)\n  }\n  return { dep, inserted }\n}\n\nexport function mergeDeps(toMerge: NestedValues, onlyIfMissing = false) {\n  const flattened = flatten(toMerge)\n  for (const [path, value] of Object.entries(flattened)) {\n    const hasKey = dependencies.has(path)\n    if (hasKey && onlyIfMissing) continue\n    setDepValue(path, value)\n  }\n}\n\nexport function removeDeps(...paths: string[]) {\n  // remove the path from dependencies with the given path prefix\n  for (const path of paths) {\n    const subPaths = depRange(path)\n    for (const subPath of subPaths) {\n      dependencies.delete(subPath)\n      const index = dependencyPaths.indexOf(subPath)\n      if (index > -1) {\n        dependencyPaths.splice(index, 1)\n      }\n      removed?.add(subPath)\n    }\n  }\n}\n\nexport function json(shouldIndent = true, onlyPublic = false) {\n  return JSON.stringify(nested(onlyPublic), null, shouldIndent ? 2 : 0)\n}\n\nexport type NestedValues = { [key: string]: NestedValues | any }\n\nexport function nested(onlyPublic: boolean, ...subPaths: string[]) {\n  const filtered = new Map<string, any>()\n  for (const path of dependencyPaths) {\n    if (onlyPublic && path.match(/^_|\\._/)) {\n      continue\n    }\n    if (subPaths.length > 0) {\n      let found = false\n      for (const subPath of subPaths) {\n        if (path.startsWith(subPath)) {\n          found = true\n          break\n        }\n      }\n      if (!found) {\n        continue\n      }\n    }\n    filtered.set(path, dependencies.get(path)?.value)\n  }\n  const nv = unflatten(filtered)\n  return nv\n}\n\nfunction isPlainObject(value: any): boolean {\n  return Object.prototype.toString.call(value) === '[object Object]'\n}\n\nfunction flatten(\n  obj: Record<string, any>,\n  roots: string[] = [],\n  sep = '.',\n): object {\n  return Object.keys(obj).reduce((memo: Record<string, any>, prop: string) => {\n    return Object.assign(\n      {},\n      memo,\n      isPlainObject(obj[prop])\n        ? flatten(obj[prop], roots.concat([prop]), sep)\n        : { [roots.concat([prop]).join(sep)]: obj[prop] },\n    )\n  }, {})\n}\n\nfunction unflatten(obj: Map<string, Dependency>, sep = '.'): NestedValues {\n  const result: NestedValues = {}\n  for (const [key, value] of obj.entries()) {\n    const keys = key.split(sep)\n    let current = result\n    for (let i = 0; i < keys.length - 1; i++) {\n      const k = keys[i]\n      if (!current[k]) {\n        current[k] = {}\n      }\n      current = current[k]\n    }\n    current[keys[keys.length - 1]] = value\n  }\n  return result\n}\n\nexport function evalRX<T>(\n  rxFn: (...argsThenDeps: any[]) => T,\n  dm: boolean[],\n  deps: Dependency[],\n  ...args: any[]\n) {\n  return batch(() =>\n    rxFn(...args, ...deps.map((dep, index) => (dm[index] ? dep : dep.value))),\n  )\n}\n\ninterface AlienDependency {\n  subs?: Link\n  subsTail?: Link\n}\n\ninterface Subscriber {\n  flags: SubscriberFlags\n  deps?: Link\n  depsTail?: Link\n}\n\ninterface Link {\n  dep: AlienDependency | (AlienDependency & Subscriber)\n  sub: Subscriber | (AlienDependency & Subscriber)\n  prevSub?: Link\n  nextSub?: Link\n  nextDep?: Link\n}\n\ninterface OneWayLink<T> {\n  target: T\n  linked?: OneWayLink<T>\n}\n\n// biome-ignore lint/suspicious/noConstEnum: <explanation>\nconst enum SubscriberFlags {\n  Computed = 1 << 0,\n  Effect = 1 << 1,\n  Tracking = 1 << 2,\n  Notified = 1 << 3,\n  Recursed = 1 << 4,\n  Dirty = 1 << 5,\n  PendingComputed = 1 << 6,\n  PendingEffect = 1 << 7,\n  Propagated = Dirty | PendingComputed | PendingEffect,\n}\n\nconst args: any[][] = []\nconst notifyBuffer: (Subscriber | undefined)[] = []\nlet notifyIndex = 0\nlet notifyBufferLength = 0\n\nfunction getter<T>(deps: Dependency[], fn: (...args: any[]) => T): () => T {\n  switch (deps.length) {\n    case 0:\n      return fn\n    case 1:\n      return () => fn(deps[0].value)\n    case 2:\n      return () => fn(deps[0].value, deps[1].value)\n    case 3:\n      return () => fn(deps[0].value, deps[1].value, deps[2].value)\n    case 4:\n      return () =>\n        fn(deps[0].value, deps[1].value, deps[2].value, deps[3].value)\n  }\n\n  const len = deps.length\n  if (!args[len]) {\n    args[len] = Array(len)\n  }\n\n  return () => {\n    for (let i = 0; i < len; i++) {\n      args[len][i] = deps[i].value\n    }\n    return fn(...args[len])\n  }\n}\n\nfunction updateComputed(computed: Computed) {\n  computed.flags &= ~(\n    SubscriberFlags.Notified |\n    SubscriberFlags.Recursed |\n    SubscriberFlags.Propagated\n  )\n  const oldValue = computed.currentValue\n  const newValue = computed.getter()\n  if (oldValue !== newValue) {\n    computed.currentValue = newValue\n    // if (computed.path) {\n    //   updated.add(computed.path)\n    // }\n    return true\n  }\n  return false\n}\n\nfunction notifyEffect(effect: Effect) {\n  const flags = effect.flags\n  if (\n    flags & SubscriberFlags.Dirty ||\n    (flags & SubscriberFlags.PendingComputed && updateDirtyFlag(effect, flags))\n  ) {\n    effect.flags &= ~(\n      SubscriberFlags.Notified |\n      SubscriberFlags.Recursed |\n      SubscriberFlags.Propagated\n    )\n    effect.run()\n  }\n  return true\n}\n\n/**\n * Updates the dirty flag for the given subscriber based on its dependencies.\n *\n * If the subscriber has any pending computeds, this function sets the Dirty flag\n * and returns `true`. Otherwise, it clears the PendingComputed flag and returns `false`.\n *\n * @param sub - The subscriber to update.\n * @param flags - The current flag set for this subscriber.\n * @returns `true` if the subscriber is marked as Dirty; otherwise `false`.\n */\nfunction updateDirtyFlag(sub: Subscriber, flags: SubscriberFlags): boolean {\n  if (checkDirty(sub.deps!)) {\n    sub.flags = flags | SubscriberFlags.Dirty\n    return true\n  }\n  sub.flags = flags & ~SubscriberFlags.PendingComputed\n  return false\n}\n\nexport function signal<T>(value: T, path?: string): Signal<T> {\n  return new Signal(value, path)\n}\n\nexport class Signal<T = unknown> implements AlienDependency {\n  // Dependency fields\n  subs?: Link\n  subsTail?: Link\n\n  constructor(\n    public currentValue: T,\n    public path?: string,\n  ) {\n    if (path) {\n      setDep(path, this)\n    }\n  }\n\n  get value(): T {\n    return this.currentValue\n  }\n\n  set value(value: T) {\n    if (this.currentValue !== value) {\n      this.currentValue = value\n\n      if (this.path) {\n        updated.add(this.path)\n      }\n      if (this.subs) {\n        // propagate\n        let current = this.subs\n        let next = current.nextSub\n        let branchs: OneWayLink<Link | undefined> | undefined\n        let branchDepth = 0\n        let targetFlag = SubscriberFlags.Dirty\n\n        top: do {\n          const sub = current.sub\n          const subFlags = sub.flags\n\n          let shouldNotify = false\n\n          if (\n            !(\n              subFlags &\n              (SubscriberFlags.Tracking |\n                SubscriberFlags.Recursed |\n                SubscriberFlags.Propagated)\n            )\n          ) {\n            sub.flags = subFlags | targetFlag | SubscriberFlags.Notified\n            shouldNotify = true\n          } else if (\n            subFlags & SubscriberFlags.Recursed &&\n            !(subFlags & SubscriberFlags.Tracking)\n          ) {\n            sub.flags =\n              (subFlags & ~SubscriberFlags.Recursed) |\n              targetFlag |\n              SubscriberFlags.Notified\n            shouldNotify = true\n          } else if (\n            !(subFlags & SubscriberFlags.Propagated) &&\n            isValidLink(current, sub)\n          ) {\n            sub.flags =\n              subFlags |\n              SubscriberFlags.Recursed |\n              targetFlag |\n              SubscriberFlags.Notified\n            shouldNotify = !!(sub as AlienDependency).subs\n          }\n\n          if (shouldNotify) {\n            const subSubs = (sub as AlienDependency).subs\n            if (subSubs) {\n              current = subSubs\n              if (subSubs.nextSub) {\n                branchs = { target: next, linked: branchs }\n                ++branchDepth\n                next = current.nextSub\n                targetFlag = SubscriberFlags.PendingComputed\n              } else {\n                targetFlag =\n                  subFlags & SubscriberFlags.Effect\n                    ? SubscriberFlags.PendingEffect\n                    : SubscriberFlags.PendingComputed\n              }\n              continue\n            }\n            if (subFlags & SubscriberFlags.Effect) {\n              notifyBuffer[notifyBufferLength++] = sub\n            }\n          } else if (!(subFlags & (SubscriberFlags.Tracking | targetFlag))) {\n            sub.flags = subFlags | targetFlag | SubscriberFlags.Notified\n            if (\n              (subFlags &\n                (SubscriberFlags.Effect | SubscriberFlags.Notified)) ===\n              SubscriberFlags.Effect\n            ) {\n              notifyBuffer[notifyBufferLength++] = sub\n            }\n          } else if (\n            !(subFlags & targetFlag) &&\n            subFlags & SubscriberFlags.Propagated &&\n            isValidLink(current, sub)\n          ) {\n            sub.flags = subFlags | targetFlag\n          }\n\n          if ((current = next!)) {\n            next = current.nextSub\n            targetFlag = branchDepth\n              ? SubscriberFlags.PendingComputed\n              : SubscriberFlags.Dirty\n            continue\n          }\n\n          while (branchDepth--) {\n            current = branchs!.target!\n            branchs = branchs!.linked\n            if (current) {\n              next = current.nextSub\n              targetFlag = branchDepth\n                ? SubscriberFlags.PendingComputed\n                : SubscriberFlags.Dirty\n              continue top\n            }\n          }\n\n          break\n          // biome-ignore lint/correctness/noConstantCondition: <explanation>\n        } while (true)\n\n        // process effect notifications\n        while (notifyIndex < notifyBufferLength) {\n          const effect = notifyBuffer[notifyIndex]!\n          notifyBuffer[notifyIndex++] = undefined\n          if (!notifyEffect(effect as Effect)) {\n            effect.flags &= ~SubscriberFlags.Notified\n          }\n        }\n        notifyIndex = 0\n        notifyBufferLength = 0\n      }\n    }\n  }\n}\n\nexport function computed<T>(\n  deps: Dependency[],\n  fn: (...args: any[]) => T,\n  path?: string,\n): Computed<T> {\n  return new Computed(deps, getter(deps, fn), path)\n}\n\nexport class Computed<T = unknown> implements Subscriber, AlienDependency {\n  currentValue?: T\n  getter: () => T\n\n  // Dependency fields\n  subs?: Link\n  subsTail?: Link\n\n  // Subscriber fields\n  deps?: Link\n  depsTail?: Link\n  flags: SubscriberFlags = SubscriberFlags.Computed | SubscriberFlags.Dirty\n\n  constructor(\n    deps: Dependency[],\n    fn: (...args: any[]) => T,\n    public path?: string,\n  ) {\n    this.getter = getter(deps, fn)\n    if (path) {\n      setDep(path, this)\n    }\n\n    for (const dep of deps) {\n      link(dep, this)\n    }\n  }\n\n  get value(): T {\n    const flags = this.flags\n    if (flags & (SubscriberFlags.PendingComputed | SubscriberFlags.Dirty)) {\n      if (flags & SubscriberFlags.Dirty || checkDirty(this.deps!)) {\n        if (updateComputed(this)) {\n          const subs = this.subs\n          if (subs) {\n            shallowPropagate(subs)\n          }\n        }\n      } else {\n        this.flags = flags & ~SubscriberFlags.PendingComputed\n      }\n    }\n    return this.currentValue!\n  }\n}\n\nexport function effect(\n  deps: Dependency[],\n  fn: (...args: any[]) => void,\n): OnRemovalFn {\n  const e = new Effect(deps, fn)\n  return () => e.dispose()\n}\n\nexport class Effect implements Subscriber {\n  deps?: Link\n  depsTail?: Link\n  flags: SubscriberFlags = SubscriberFlags.Effect\n  run: () => void\n\n  constructor(deps: Dependency[], fn: (...args: any[]) => void) {\n    for (const dep of deps) {\n      link(dep, this)\n    }\n\n    this.run = getter(deps, fn)\n    this.run()\n  }\n\n  dispose() {\n    this.depsTail = undefined\n    this.flags &= ~(\n      SubscriberFlags.Notified |\n      SubscriberFlags.Recursed |\n      SubscriberFlags.Propagated\n    )\n\n    if (this.deps) {\n      let link = this.deps\n      do {\n        const dep = link.dep\n        const nextDep = link.nextDep\n        const nextSub = link.nextSub\n        const prevSub = link.prevSub\n\n        if (nextSub) {\n          nextSub.prevSub = prevSub\n        } else {\n          dep.subsTail = prevSub\n        }\n\n        if (prevSub) {\n          prevSub.nextSub = nextSub\n        } else {\n          dep.subs = nextSub\n        }\n\n        if (!dep.subs && 'deps' in dep) {\n          const depFlags = dep.flags\n          if (!(depFlags & SubscriberFlags.Dirty)) {\n            dep.flags = depFlags | SubscriberFlags.Dirty\n          }\n          const depDeps = dep.deps\n          if (depDeps) {\n            link = depDeps\n            dep.depsTail!.nextDep = nextDep\n            dep.deps = undefined\n            dep.depsTail = undefined\n            continue\n          }\n        }\n        link = nextDep!\n      } while (link)\n\n      this.deps = undefined\n    }\n  }\n}\n\n/**\n * Links a given dependency and subscriber if they are not already linked.\n *\n * @param dep - The dependency to be linked.\n * @param sub - The subscriber that depends on this dependency.\n * @returns The newly created link object if the two are not already linked; otherwise `undefined`.\n */\nfunction link(dep: AlienDependency, sub: Subscriber): Link | undefined {\n  const currentDep = sub.depsTail\n  if (currentDep && currentDep.dep === dep) {\n    return\n  }\n  const nextDep = currentDep ? currentDep.nextDep : sub.deps\n  if (nextDep && nextDep.dep === dep) {\n    sub.depsTail = nextDep\n    return\n  }\n  const depLastSub = dep.subsTail\n  if (depLastSub && depLastSub.sub === sub && isValidLink(depLastSub, sub)) {\n    return\n  }\n\n  const newLink: Link = {\n    dep,\n    sub,\n    nextDep,\n    prevSub: undefined,\n    nextSub: undefined,\n  }\n  if (!currentDep) {\n    sub.deps = newLink\n  } else {\n    currentDep.nextDep = newLink\n  }\n  if (!dep.subs) {\n    dep.subs = newLink\n  } else {\n    const oldTail = dep.subsTail!\n    newLink.prevSub = oldTail\n    oldTail.nextSub = newLink\n  }\n  sub.depsTail = newLink\n  dep.subsTail = newLink\n  return newLink\n}\n\n/**\n * Recursively checks and updates all computed subscribers marked as pending.\n *\n * It traverses the linked structure using a stack mechanism. For each computed\n * subscriber in a pending state, updateComputed is called and shallowPropagate\n * is triggered if a value changes. Returns whether any updates occurred.\n *\n * @param current - The starting link representing a sequence of pending computeds.\n * @returns `true` if a computed was updated, otherwise `false`.\n */\nfunction checkDirty(current: Link): boolean {\n  let prevLinks: OneWayLink<Link> | undefined\n  let checkDepth = 0\n  let dirty: boolean\n\n  top: do {\n    dirty = false\n    const dep = current.dep\n\n    if (current.sub.flags & SubscriberFlags.Dirty) {\n      dirty = true\n    } else if ('flags' in dep) {\n      const depFlags = dep.flags\n      if (\n        (depFlags & (SubscriberFlags.Computed | SubscriberFlags.Dirty)) ===\n        (SubscriberFlags.Computed | SubscriberFlags.Dirty)\n      ) {\n        if (updateComputed(dep as Computed)) {\n          const subs = dep.subs!\n          if (subs.nextSub) {\n            shallowPropagate(subs)\n          }\n          dirty = true\n        }\n      } else if (\n        (depFlags &\n          (SubscriberFlags.Computed | SubscriberFlags.PendingComputed)) ===\n        (SubscriberFlags.Computed | SubscriberFlags.PendingComputed)\n      ) {\n        if (current.nextSub || current.prevSub) {\n          prevLinks = { target: current, linked: prevLinks }\n        }\n        current = dep.deps!\n        ++checkDepth\n        continue\n      }\n    }\n\n    if (!dirty && current.nextDep) {\n      current = current.nextDep\n      continue\n    }\n\n    while (checkDepth) {\n      --checkDepth\n      const sub = current.sub as AlienDependency & Subscriber\n      const firstSub = sub.subs!\n      if (dirty) {\n        if (updateComputed(sub as Computed)) {\n          if (firstSub.nextSub) {\n            current = prevLinks!.target\n            prevLinks = prevLinks!.linked\n            shallowPropagate(firstSub)\n          } else {\n            current = firstSub\n          }\n          continue\n        }\n      } else {\n        sub.flags &= ~SubscriberFlags.PendingComputed\n      }\n      if (firstSub.nextSub) {\n        current = prevLinks!.target\n        prevLinks = prevLinks!.linked\n      } else {\n        current = firstSub\n      }\n      if (current.nextDep) {\n        current = current.nextDep\n        continue top\n      }\n      dirty = false\n    }\n\n    return dirty\n    // biome-ignore lint/correctness/noConstantCondition: <explanation>\n  } while (true)\n}\n\n/**\n * Quickly propagates PendingComputed status to Dirty for each subscriber in the chain.\n *\n * If the subscriber is also marked as an effect, it is added to the queuedEffects list\n * for later processing.\n *\n * @param link - The head of the linked list to process.\n */\nfunction shallowPropagate(link: Link): void {\n  do {\n    const sub = link.sub\n    const subFlags = sub.flags\n    if (\n      (subFlags & (SubscriberFlags.PendingComputed | SubscriberFlags.Dirty)) ===\n      SubscriberFlags.PendingComputed\n    ) {\n      sub.flags = subFlags | SubscriberFlags.Dirty | SubscriberFlags.Notified\n      if (\n        (subFlags & (SubscriberFlags.Effect | SubscriberFlags.Notified)) ===\n        SubscriberFlags.Effect\n      ) {\n        notifyBuffer[notifyBufferLength++] = sub\n      }\n    }\n    link = link.nextSub!\n  } while (link)\n}\n\n/**\n * Verifies whether the given link is valid for the specified subscriber.\n *\n * It iterates through the subscriber's link list (from sub.deps to sub.depsTail)\n * to determine if the provided link object is part of that chain.\n *\n * @param checkLink - The link object to validate.\n * @param sub - The subscriber whose link list is being checked.\n * @returns `true` if the link is found in the subscriber's list; otherwise `false`.\n */\nfunction isValidLink(checkLink: Link, sub: Subscriber): boolean {\n  const depsTail = sub.depsTail\n  if (depsTail) {\n    let link = sub.deps!\n    do {\n      if (link === checkLink) {\n        return true\n      }\n      if (link === depsTail) {\n        break\n      }\n      link = link.nextDep!\n    } while (link)\n  }\n  return false\n}\n", "import {\n  type NestedValues,\n  mergeDeps,\n  setDepValue,\n  upsertIfMissing,\n} from '../../../engine/signals'\nimport { type AttributePlugin, PluginType } from '../../../engine/types'\nimport { modifyCasing } from '../../../utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'signals',\n  onLoad: (ctx) => {\n    const { key, mods, value, genRX, evalRX, batch } = ctx\n    const { deps, dm, rxFn } = genRX()\n    const ifMissing = mods.has('ifmissing')\n\n    if (key !== '') {\n      const k = modifyCasing(key, mods)\n      const v = value === '' ? value : evalRX(rxFn, dm, deps)\n      batch(() => {\n        if (ifMissing) {\n          upsertIfMissing(k, v)\n        } else {\n          setDepValue(k, v)\n        }\n      })\n    } else {\n      const nv = evalRX<NestedValues>(rxFn, dm, deps)\n      batch(() => {\n        mergeDeps(nv, ifMissing)\n      })\n    }\n  },\n}\n", "import type { HTMLOrSVGElement } from '../engine/types'\n\nexport function isHTMLOrSVG(el: Node): el is HTMLOrSVGElement {\n  return el instanceof HTMLElement || el instanceof SVGElement\n}\n\nexport function walkDOM(\n  element: Node,\n  callback: (el: HTMLOrSVGElement) => void,\n) {\n  const iter = document.createTreeWalker(\n    element,\n    1 /* NodeFilter.SHOW_ELEMENT */,\n  )\n  while (element) {\n    if (isHTMLOrSVG(element)) {\n      const dataset = element.dataset\n      if ('ignore' in dataset) {\n        element = iter.nextSibling()!\n        continue\n      }\n      if (!('ignore__self' in dataset)) {\n        callback(element)\n      }\n    }\n    element = iter.nextNode()!\n  }\n}\n", "import { snake } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport { depPaths } from './signals'\nimport { type InitContext, PluginType, type RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  e.name = `${DATASTAR} ${type} error`\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(reason: string, ctx: InitContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(reason: string, ctx: RuntimeContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      validSignals: depPaths(),\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n", "import { walkDOM } from '../utils/dom'\nimport { camel, snake } from '../utils/text'\nimport { DATASTAR, DSP, DSS } from './consts'\nimport { initErr, runtimeErr } from './errors'\nimport {\n  computed,\n  dep,\n  depPaths,\n  effect,\n  signal,\n  batch,\n  evalRX,\n} from './signals'\nimport {\n  type ActionPlugins,\n  type AttributePlugin,\n  type DatastarPlugin,\n  type Dependency,\n  type HTMLOrSVGElement,\n  type InitContext,\n  type OnRemovalFn,\n  PluginType,\n  Requirement,\n  type RuntimeContext,\n  type RuntimeExpressionFunction,\n} from './types'\n\nconst actions: ActionPlugins = {}\nconst plugins: AttributePlugin[] = []\n\n// Map of cleanup functions by element, keyed by a dataset key-value hash\nconst removals = new Map<HTMLOrSVGElement, Map<string, OnRemovalFn>>()\n\nlet mutationObserver: MutationObserver | null = null\n\nlet alias = ''\nexport function setAlias(value: string) {\n  alias = value\n}\n\nexport function load(...pluginsToLoad: DatastarPlugin[]) {\n  for (const plugin of pluginsToLoad) {\n    const ctx: InitContext = {\n      plugin,\n      actions,\n      removals,\n      applyToElement,\n      batch,\n      signal,\n      computed,\n      effect,\n    }\n\n    const type = plugin.type\n    if (type === PluginType.Action) {\n      actions[plugin.name] = plugin\n    } else if (type === PluginType.Attribute) {\n      plugins.push(plugin)\n      plugin.onGlobalInit?.(ctx)\n    } else if (type === PluginType.Watcher) {\n      plugin.onGlobalInit?.(ctx)\n    } else {\n      throw initErr('InvalidPluginType', ctx)\n    }\n  }\n\n  // Sort attribute plugins by descending length then alphabetically\n  plugins.sort((a, b) => {\n    const lenDiff = b.name.length - a.name.length\n    if (lenDiff !== 0) return lenDiff\n    return a.name.localeCompare(b.name)\n  })\n}\n\n// Apply all plugins to all elements in the DOM\nexport function apply() {\n  // Delay applying plugins to give custom plugins a chance to load\n  queueMicrotask(() => {\n    walkDOM(document.documentElement, applyToElement)\n\n    // Monitor the entire document body for changes\n    // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n    mutationObserver = new MutationObserver(observe)\n    // Run the observer once to start listening\n    observe([])\n  })\n}\n\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe(mutations: MutationRecord[]) {\n  // Don't track mutations because we cause mutations inside of this callback. Without this, we\n  // would get an infinite loop\n  mutationObserver!.disconnect()\n\n  for (const { target, type, addedNodes, removedNodes } of mutations) {\n    switch (type) {\n      case 'childList':\n        {\n          // We don't care about the order of removals\n          for (const node of removedNodes) {\n            walkDOM(node, (el) => {\n              const elCleanups = removals.get(el)\n              // If removals has el, delete it and run all cleanup functions\n              if (removals.delete(el)) {\n                for (const cleanup of elCleanups!.values()) {\n                  cleanup()\n                }\n                elCleanups!.clear()\n              }\n            })\n          }\n          for (const node of addedNodes) {\n            // Set the `data-apply` attribute on all new nodes so we can come back and apply plugins\n            // in the order they appear in the dom\n            walkDOM(node, (el) => {\n              el.setAttribute('data-apply', '')\n            })\n          }\n        }\n        break\n      case 'attributes': {\n        ;(target as HTMLOrSVGElement).setAttribute('data-apply', '')\n        break\n      }\n    }\n  }\n\n  // `querySelectorAll` will collect all elements with the `data-apply` attribute in the order they\n  // appear in the dom\n  for (const el of document.querySelectorAll('[data-apply]')) {\n    el.removeAttribute('data-apply')\n    applyToElement(el as HTMLOrSVGElement)\n  }\n\n  // Start tracking again\n  mutationObserver!.observe(document.body, {\n    subtree: true,\n    childList: true,\n    attributes: true,\n  })\n}\n\n// use djb2 favored by bernstein http://www.cse.yorku.ca/~oz/hash.html\nfunction djb2(str: string) {\n  let hash = 5831\n  let i = str.length\n  while (i--) {\n    hash += (hash << 5) + str.charCodeAt(i)\n  }\n  return (hash >>> 0).toString(36)\n}\n\ntype ToApply = {\n  key: string\n  value: string\n  hash: string\n}\n\n// Apply all plugins to the element\nfunction applyToElement(el: HTMLOrSVGElement) {\n  // Check if the element has any data attributes already\n  const toApply: ToApply[] = []\n  const elCleanups = removals.get(el) || new Map()\n  const toCleanup = new Map(elCleanups)\n\n  // Apply the plugins to the element in order of application\n  // since DOMStringMap is ordered, we can be deterministic\n  for (const [key, value] of Object.entries(el.dataset) as [string, string][]) {\n    // Ignore data attributes that don\u2019t start with the alias\n    if (!key.startsWith(alias)) {\n      continue\n    }\n\n    const hash = djb2(`${key}${value}`)\n\n    // If toCleanup has hash, delete it, else push to toApply\n    if (!toCleanup.delete(hash)) {\n      toApply.push({ key, value, hash })\n    }\n  }\n\n  // Cleanup the left over plugins and delete them from elCleanups\n  for (const [hash, cleanup] of toCleanup) {\n    cleanup()\n    elCleanups.delete(hash)\n  }\n\n  for (const { key, value, hash } of toApply) {\n    // Apply the plugin to the element\n    const cleanup = applyAttributePlugin(el, key, value)\n    if (cleanup) {\n      // Store the cleanup function\n      elCleanups.set(hash, cleanup)\n    }\n  }\n  // If elCleanups has any cleanups, set it in removals\n  if (elCleanups.size) {\n    removals.set(el, elCleanups)\n  }\n}\n\nfunction applyAttributePlugin(\n  el: HTMLOrSVGElement,\n  datasetKey: string,\n  value: string,\n) {\n  // Extract the raw key from the dataset\n  const rawKey = camel(datasetKey.slice(alias.length))\n\n  // Find the plugin that matches, since the plugins are sorted by length descending and alphabetically. The first match will be the most specific.\n  // Ignore keys with the plugin name as a prefix (ignores `classes` but not `classBold`)\n  const plugin = plugins.find((p) =>\n    RegExp(`^${p.name}([A-Z]|_|$)`).test(rawKey),\n  )\n\n  // Skip if no plugin is found\n  if (!plugin) return\n\n  // Extract the key and modifiers\n  let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/\\_\\_+/)\n\n  const hasKey = !!key\n  if (hasKey) {\n    key = camel(key)\n  }\n  const hasValue = !!value\n\n  // Create the runtime context\n  const ctx: RuntimeContext = {\n    applyToElement,\n    actions,\n    removals,\n    genRX: () => genRX(ctx, ...(plugin.argNames || [])),\n    plugin,\n    el,\n    rawKey,\n    key,\n    value,\n    mods: new Map(),\n    batch,\n    signal,\n    computed,\n    effect,\n    evalRX,\n  }\n\n  // Check the requirements\n  const keyReq = plugin.keyReq || Requirement.Allowed\n  if (hasKey) {\n    if (keyReq === Requirement.Denied) {\n      throw runtimeErr(`${plugin.name}KeyNotAllowed`, ctx)\n    }\n  } else if (keyReq === Requirement.Must) {\n    throw runtimeErr(`${plugin.name}KeyRequired`, ctx)\n  }\n\n  const valReq = plugin.valReq || Requirement.Allowed\n  if (hasValue) {\n    if (valReq === Requirement.Denied) {\n      throw runtimeErr(`${plugin.name}ValueNotAllowed`, ctx)\n    }\n  } else if (valReq === Requirement.Must) {\n    throw runtimeErr(`${plugin.name}ValueRequired`, ctx)\n  }\n\n  // Check for exclusive requirements\n  if (keyReq === Requirement.Exclusive || valReq === Requirement.Exclusive) {\n    if (hasKey && hasValue) {\n      throw runtimeErr(`${plugin.name}KeyAndValueProvided`, ctx)\n    }\n    if (!hasKey && !hasValue) {\n      throw runtimeErr(`${plugin.name}KeyOrValueRequired`, ctx)\n    }\n  }\n\n  for (const rawMod of rawModifiers) {\n    const [label, ...mod] = rawMod.split('.')\n    ctx.mods.set(camel(label), new Set(mod.map((t) => t.toLowerCase())))\n  }\n\n  // Load the plugin and return the cleanup function\n  return plugin.onLoad(ctx)\n}\n\nfunction genRX(\n  ctx: RuntimeContext,\n  ...argNames: string[]\n): {\n  deps: Dependency[]\n  dm: boolean[] // dependency mutable flags\n  rxFn: RuntimeExpressionFunction\n} {\n  const dm: boolean[] = []\n  const dependencySet = new Set<Dependency>()\n  let expr = ''\n\n  // This regex allows Datastar expressions to support nested\n  // regex and strings that contain ; without breaking.\n  //\n  // Each of these regex defines a block type we want to match\n  // (importantly we ignore the content within these blocks):\n  //\n  // regex            \\/(\\\\\\/|[^\\/])*\\/\n  // double quotes      \"(\\\\\"|[^\\\"])*\"\n  // single quotes      '(\\\\'|[^'])*'\n  // ticks              `(\\\\`|[^`])*`\n  //\n  // We also want to match the non delimiter part of statements\n  // note we only support ; statement delimiters:\n  //\n  // [^;]\n  //\n  const statementRe =\n    /(\\/(\\\\\\/|[^\\/])*\\/|\"(\\\\\"|[^\\\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|[^;])+/gm\n  const statements = ctx.value.trim().match(statementRe)\n  if (statements) {\n    const lastIdx = statements.length - 1\n    const last = statements[lastIdx].trim()\n    if (!last.startsWith('return')) {\n      statements[lastIdx] = `return (${last});`\n    }\n    expr = statements.join(';\\n')\n  }\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  for (const match of expr.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = `dsEscaped${djb2(k)}`\n    escaped.set(v, k)\n    expr = expr.replace(DSP + k + DSS, v)\n  }\n\n  const nameGen = (prefix: string, name: string) => {\n    return `${prefix}${snake(name).replaceAll(/\\./g, '_')}`\n  }\n\n  const argsDependenciesActionsNames = new Set<string>(argNames)\n  const dependencyPaths = depPaths()\n  if (dependencyPaths.length) {\n    const pattern = dependencyPaths\n      .toSorted((a, b) => b.length - a.length)\n      .join('|')\n\n    const signalsWithAssignedValuesRe = RegExp(\n      `\\\\$(${pattern})(\\\\s*[+&^\\\\/*|-]?=[^=]|\\\\+\\\\+|--)`,\n      'gm',\n    )\n    const signalsWithAssignedValuesMatches = [\n      ...expr.matchAll(signalsWithAssignedValuesRe),\n    ]\n\n    const updateUserExpression = (\n      match: RegExpExecArray,\n      name: string,\n      suffix = '',\n    ) => {\n      expr = expr.replaceAll(`$${match[1]}`, name + suffix)\n    }\n\n    if (signalsWithAssignedValuesMatches.length) {\n      const signalMutationPrefix = `${DATASTAR}Mut_`\n      const mutableDependencies = new Set<Dependency>()\n      for (const match of signalsWithAssignedValuesMatches) {\n        const depName = match[1]\n        const d = dep(depName)\n        const name = nameGen(signalMutationPrefix, depName)\n        if (d && !mutableDependencies.has(d)) {\n          dependencySet.add(d)\n          mutableDependencies.add(d)\n          dm.push(true)\n          argsDependenciesActionsNames.add(name)\n        }\n        updateUserExpression(match, `${name}`, '.value')\n      }\n    }\n\n    const pureDependencyRe = RegExp(`\\\\$(${pattern})(\\\\W|$)`, 'gm')\n    const allPureDependenciesMatches = [...expr.matchAll(pureDependencyRe)]\n    if (allPureDependenciesMatches.length) {\n      const pureDependencyPrefix = `${DATASTAR}Pure_`\n      const pureDependencies = new Set<Dependency>()\n      for (const match of allPureDependenciesMatches) {\n        const pureDepName = match[1]\n        const pureDep = dep(pureDepName)\n        const name = nameGen(pureDependencyPrefix, pureDepName)\n        if (pureDep && !pureDependencies.has(pureDep)) {\n          dependencySet.add(pureDep)\n          pureDependencies.add(pureDep)\n          dm.push(false)\n          argsDependenciesActionsNames.add(name)\n        }\n        updateUserExpression(match, name)\n      }\n    }\n  }\n\n  // Replace any action calls\n  const actionsCalled = new Set<string>()\n  const actionsRe = RegExp(`@(${Object.keys(actions).join('|')})\\\\(`, 'gm')\n  const actionMatches = [...expr.matchAll(actionsRe)]\n  const actionFns = new Set<(...args: any[]) => any>()\n  if (actionMatches.length) {\n    const actionPrefix = `${DATASTAR}Act_`\n    for (const match of actionMatches) {\n      const actionName = match[1]\n      const action = actions[actionName]\n      if (!action) {\n        continue\n      }\n      actionsCalled.add(actionName)\n\n      const name = nameGen(actionPrefix, actionName)\n      argsDependenciesActionsNames.add(name)\n      // Add ctx to action calls\n      expr = expr.replace(`@${actionName}(`, `${name}(`)\n      actionFns.add((...args: any[]) => action.fn(ctx, ...args))\n    }\n  }\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    expr = expr.replace(k, v)\n  }\n\n  ctx.fnContent = expr\n\n  try {\n    const fn = Function('el', ...argsDependenciesActionsNames, expr)\n    return {\n      dm,\n      deps: [...dependencySet],\n      rxFn: (...argsAndDependencyValues: any[]) => {\n        try {\n          return fn(ctx.el, ...argsAndDependencyValues, ...actionFns)\n        } catch (e: any) {\n          throw runtimeErr('ExecuteExpression', ctx, {\n            error: e.message,\n          })\n        }\n      },\n    }\n  } catch (error: any) {\n    throw runtimeErr('GenerateExpression', ctx, {\n      error: error.message,\n    })\n  }\n}\n", "import { DSP } from '../engine/consts'\n// @ts-ignore\nconst _ = DSP // This is to force the import of DSP first in the compiled code\n\nimport { Computed } from '../plugins/core/attributes/computed'\nimport { Signals } from '../plugins/core/attributes/signals'\nimport { apply, load, setAlias } from './engine'\n\nload(Signals, Computed)\n\nexport { apply, load, setAlias }\n", "import { DATASTAR } from '../../../engine/consts'\n\nexport const DATASTAR_SSE_EVENT = `${DATASTAR}-sse`\nexport const STARTED = 'started'\nexport const FINISHED = 'finished'\nexport const ERROR = 'error'\nexport const RETRYING = 'retrying'\nexport const RETRIES_FAILED = 'retrying'\n\nexport interface DatastarSSEEvent {\n  type: string\n  el: HTMLOrSVGElement\n  argsRaw: Record<string, string>\n}\n\nexport interface CustomEventMap {\n  [DATASTAR_SSE_EVENT]: CustomEvent<DatastarSSEEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\n\ndeclare global {\n  interface Document {\n    //adds definition to Document, but you can do the same with HTMLElement\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n  }\n}\n\nexport function datastarSSEEventWatcher(\n  eventType: string,\n  fn: (argsRaw: Record<string, string>) => void,\n) {\n  document.addEventListener(\n    DATASTAR_SSE_EVENT,\n    (event: CustomEvent<DatastarSSEEvent>) => {\n      if (event.detail.type !== eventType) {\n        return\n      }\n      const { argsRaw } = event.detail\n      fn(argsRaw)\n    },\n  )\n}\n", "// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DATASTAR,\n  DATASTAR_REQUEST,\n  DefaultSseRetryDurationMs,\n} from '../../../../engine/consts'\nimport { runtimeErr } from '../../../../engine/errors'\nimport { json } from '../../../../engine/signals'\nimport type { RuntimeContext } from '../../../../engine/types'\nimport {\n  DATASTAR_SSE_EVENT,\n  type DatastarSSEEvent,\n  ERROR,\n  FINISHED,\n  RETRIES_FAILED,\n  RETRYING,\n  STARTED,\n} from '../shared'\n\nfunction dispatchSSE(\n  type: string,\n  el: HTMLOrSVGElement,\n  argsRaw: Record<string, string>,\n) {\n  document.dispatchEvent(\n    new CustomEvent<DatastarSSEEvent>(DATASTAR_SSE_EVENT, {\n      detail: { type, el, argsRaw },\n    }),\n  )\n}\n\nconst isWrongContent = (err: any) => `${err}`.includes('text/event-stream')\nconst shouldSendUsingQueryParams = (method: string) => method === 'GET'\n\nexport type SSEArgs = {\n  headers?: Record<string, string>\n  openWhenHidden?: boolean\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  abort?: AbortSignal\n} & (\n  | {\n      contentType: 'json'\n      includeLocal?: boolean\n      excludeSignals?: boolean\n    }\n  | {\n      contentType: 'form'\n      selector?: string\n    }\n)\n\nexport const sse = async (\n  ctx: RuntimeContext,\n  method: string,\n  url: string,\n  args: SSEArgs,\n) => {\n  const { el, evt } = ctx\n  const {\n    headers: userHeaders,\n    contentType,\n    includeLocal,\n    excludeSignals,\n    selector,\n    openWhenHidden,\n    retryInterval,\n    retryScaler,\n    retryMaxWaitMs,\n    retryMaxCount,\n    abort,\n  } = Object.assign(\n    {\n      headers: {},\n      contentType: 'json',\n      includeLocal: false,\n      excludeSignals: false,\n      selector: null,\n      openWhenHidden: false, // will keep the request open even if the document is hidden.\n      retryInterval: DefaultSseRetryDurationMs, // the retry interval in milliseconds\n      retryScaler: 2, // the amount to multiply the retry interval by each time\n      retryMaxWaitMs: 30_000, // the maximum retry interval in milliseconds\n      retryMaxCount: 10, // the maximum number of retries before giving up\n      abort: undefined,\n    },\n    args,\n  )\n  const action = method.toLowerCase()\n  let cleanupFn = (): void => {}\n  try {\n    if (!url?.length) {\n      throw runtimeErr('SseNoUrlProvided', ctx, { action })\n    }\n\n    const initialHeaders: Record<string, any> = {}\n    initialHeaders[DATASTAR_REQUEST] = true\n    // We ignore the content-type header if using form data\n    // if missing the boundary will be set automatically\n    if (contentType === 'json') {\n      initialHeaders['Content-Type'] = 'application/json'\n    }\n    const headers = Object.assign({}, initialHeaders, userHeaders)\n\n    const req: FetchEventSourceInit = {\n      method,\n      headers,\n      openWhenHidden,\n      retryInterval,\n      retryScaler,\n      retryMaxWaitMs,\n      retryMaxCount,\n      signal: abort,\n      onopen: async (response: Response) => {\n        if (response.status >= 400) {\n          const status = response.status.toString()\n          dispatchSSE(ERROR, el, { status })\n        }\n      },\n      onmessage: (evt) => {\n        if (!evt.event.startsWith(DATASTAR)) {\n          return\n        }\n        const type = evt.event\n        const argsRawLines: Record<string, string[]> = {}\n\n        const lines = evt.data.split('\\n')\n        for (const line of lines) {\n          const colonIndex = line.indexOf(' ')\n          const key = line.slice(0, colonIndex)\n          let argLines = argsRawLines[key]\n          if (!argLines) {\n            argLines = []\n            argsRawLines[key] = argLines\n          }\n          const value = line.slice(colonIndex + 1)\n          argLines.push(value)\n        }\n\n        const argsRaw: Record<string, string> = {}\n        for (const [key, lines] of Object.entries(argsRawLines)) {\n          argsRaw[key] = lines.join('\\n')\n        }\n\n        dispatchSSE(type, el, argsRaw)\n      },\n      onerror: (error) => {\n        if (isWrongContent(error)) {\n          // don't retry if the content-type is wrong\n          throw runtimeErr('InvalidContentType', ctx, { url })\n        }\n        // do nothing and it will retry\n        if (error) {\n          console.error(error.message)\n          dispatchSSE(RETRYING, el, { message: error.message })\n        }\n      },\n    }\n\n    const urlInstance = new URL(url, window.location.href)\n    const queryParams = new URLSearchParams(urlInstance.search)\n\n    if (contentType === 'json') {\n      if (!excludeSignals) {\n        const res = json(false, !includeLocal)\n        if (shouldSendUsingQueryParams(method)) {\n          queryParams.set(DATASTAR, res)\n        } else {\n          req.body = res\n        }\n      }\n    } else if (contentType === 'form') {\n      const formEl = selector\n        ? document.querySelector(selector)\n        : el.closest('form')\n      if (formEl === null) {\n        if (selector) {\n          throw runtimeErr('SseFormNotFound', ctx, { action, selector })\n        }\n        throw runtimeErr('SseClosestFormNotFound', ctx, { action })\n      }\n\n      // Validate the form\n      if (!formEl.checkValidity()) {\n        formEl.reportValidity()\n        cleanupFn()\n        return\n      }\n\n      // Collect the form data\n      const formData = new FormData(formEl)\n      let submitter = el as HTMLElement|null\n      \n      if (el === formEl) {\n        // Get the submitter from the event\n        if (evt instanceof SubmitEvent) {\n          submitter = evt.submitter\n        }\n      } else {\n        // Prevent the form being submitted\n        const preventDefault = (evt: Event) => evt.preventDefault()\n        formEl.addEventListener('submit', preventDefault)\n        cleanupFn = (): void =>\n          formEl.removeEventListener('submit', preventDefault)\n      }\n\n      // Append the value of the form submitter if it is a button with a name\n      if (submitter instanceof HTMLButtonElement) {\n        const name = submitter.getAttribute('name')\n        if (name) {\n          formData.append(name, submitter.value)\n        }\n      }\n\n      const multipart = formEl.getAttribute('enctype') === 'multipart/form-data'\n      // Leave the `Content-Type` header empty for multipart encoding so the browser can set it automatically with the correct boundary\n      if (!multipart) {\n        headers['Content-Type'] = 'application/x-www-form-urlencoded'\n      }\n\n      const formParams = new URLSearchParams(formData as any)\n      if (shouldSendUsingQueryParams(method)) {\n        for (const [key, value] of formParams) {\n          queryParams.append(key, value)\n        }\n      } else if (multipart) {\n        req.body = formData\n      } else {\n        req.body = formParams\n      }\n    } else {\n      throw runtimeErr('SseInvalidContentType', ctx, { action, contentType })\n    }\n\n    dispatchSSE(STARTED, el, {})\n    urlInstance.search = queryParams.toString()\n\n    try {\n      await fetchEventSource(urlInstance.toString(), el, req)\n    } catch (error) {\n      if (!isWrongContent(error)) {\n        throw runtimeErr('SseFetchFailed', ctx, { method, url, error })\n      }\n      // exit gracefully and do nothing if the content-type is wrong\n      // this can happen if the client is sending a request\n      // where no response is expected, and they haven't\n      // set the content-type to text/event-stream\n    }\n  } finally {\n    dispatchSSE(FINISHED, el, {})\n    cleanupFn()\n  }\n}\n\n// Below originally from https://github.com/Azure/fetch-event-source/blob/main/LICENSE\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\ninterface EventSourceMessage {\n  /** The event ID to set the EventSource object's last event ID value. */\n  id: string\n  /** A string identifying the type of event described. */\n  event: string\n  /** The event data */\n  data: string\n  /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n  retry?: number\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nasync function getBytes(\n  stream: ReadableStream<Uint8Array>,\n  onChunk: (arr: Uint8Array) => void,\n) {\n  const reader = stream.getReader()\n  let result: ReadableStreamReadResult<Uint8Array>\n  result = await reader.read()\n  while (!result.done) {\n    onChunk(result.value)\n    result = await reader.read()\n  }\n}\n\nenum ControlChars {\n  NewLine = 10,\n  CarriageReturn = 13,\n  Space = 32,\n  Colon = 58,\n}\n\nfunction getLines(onLine: (line: Uint8Array, fieldLength: number) => void) {\n  let buffer: Uint8Array | undefined\n  let position: number // current read position\n  let fieldLength: number // length of the `field` portion of the line\n  let discardTrailingNewline = false\n\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr: Uint8Array) {\n    if (buffer === undefined) {\n      buffer = arr\n      position = 0\n      fieldLength = -1\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr)\n    }\n\n    const bufLength = buffer.length\n    let lineStart = 0 // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === ControlChars.NewLine) {\n          lineStart = ++position // skip to next char\n        }\n\n        discardTrailingNewline = false\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1 // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case ControlChars.Colon:\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart\n            }\n            break\n          // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n          // biome-ignore lint/suspicious/noFallthroughSwitchClause: <explanation>\n          case ControlChars.CarriageReturn:\n            discardTrailingNewline = true\n          case ControlChars.NewLine:\n            lineEnd = position\n            break\n        }\n      }\n\n      if (lineEnd === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next arr and then continue parsing:\n        break\n      }\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength)\n      lineStart = position // we're now on the next line\n      fieldLength = -1\n    }\n\n    if (lineStart === bufLength) {\n      buffer = undefined // we've finished reading it\n    } else if (lineStart !== 0) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart)\n      position -= lineStart\n    }\n  }\n}\n\nfunction getMessages(\n  onId: (id: string) => void,\n  onRetry: (retry: number) => void,\n  onMessage?: (msg: EventSourceMessage) => void,\n) {\n  let message = newMessage()\n  const decoder = new TextDecoder()\n\n  // return a function that can process each incoming line buffer:\n  return function onLine(line: Uint8Array, fieldLength: number) {\n    if (line.length === 0) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message)\n      message = newMessage()\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength))\n      const valueOffset =\n        fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1)\n      const value = decoder.decode(line.subarray(valueOffset))\n\n      switch (field) {\n        case 'data':\n          // if this message already has data, append the new value to the old.\n          // otherwise, just set to the new value:\n          message.data = message.data ? `${message.data}\\n${value}` : value // otherwise,\n          break\n        case 'event':\n          message.event = value\n          break\n        case 'id':\n          onId((message.id = value))\n          break\n        case 'retry': {\n          const retry = Number.parseInt(value, 10)\n          if (!Number.isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry((message.retry = retry))\n          }\n          break\n        }\n      }\n    }\n  }\n}\n\nfunction concat(a: Uint8Array, b: Uint8Array) {\n  const res = new Uint8Array(a.length + b.length)\n  res.set(a)\n  res.set(b, a.length)\n  return res\n}\n\nfunction newMessage(): EventSourceMessage {\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  return { data: '', event: '', id: '', retry: undefined }\n}\n\nconst EventStreamContentType = 'text/event-stream'\nconst LastEventId = 'last-event-id'\n\ninterface FetchEventSourceInit extends RequestInit {\n  headers?: Record<string, string>\n  onopen?: (response: Response) => Promise<void>\n  onmessage?: (ev: EventSourceMessage) => void\n  onclose?: () => void\n  onerror?: (err: any) => number | null | undefined | void\n  openWhenHidden?: boolean\n  fetch?: typeof fetch\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n}\n\nfunction fetchEventSource(\n  input: RequestInfo,\n  el: HTMLOrSVGElement,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch,\n    retryInterval = 1_000,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    ...rest\n  }: FetchEventSourceInit,\n) {\n  return new Promise<void>((resolve, reject) => {\n    let retries = 0\n\n    // make a copy of the input headers since we may modify it below:\n    const headers = { ...inputHeaders }\n    if (!headers.accept) {\n      headers.accept = EventStreamContentType\n    }\n\n    let curRequestController: AbortController\n    function onVisibilityChange() {\n      curRequestController.abort() // close existing request on every visibility change\n      if (!document.hidden) {\n        create() // page is now visible again, recreate request.\n      }\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange)\n    }\n\n    let retryTimer = 0\n    function dispose() {\n      document.removeEventListener('visibilitychange', onVisibilityChange)\n      window.clearTimeout(retryTimer)\n      curRequestController.abort()\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose()\n      resolve() // don't waste time constructing/logging errors\n    })\n\n    const fetch = inputFetch ?? window.fetch\n    const onopen = inputOnOpen ?? function defaultOnOpen() {}\n\n    async function create() {\n      curRequestController = new AbortController()\n      try {\n        const response = await fetch(input, {\n          ...rest,\n          headers,\n          signal: curRequestController.signal,\n        })\n\n        await onopen(response)\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              (id) => {\n                if (id) {\n                  // signals the id and send it back on the next retry:\n                  headers[LastEventId] = id\n                } else {\n                  // don't send the last-event-id header anymore:\n                  delete headers[LastEventId]\n                }\n              },\n              (retry) => {\n                retryInterval = retry\n              },\n              onmessage,\n            ),\n          ),\n        )\n\n        onclose?.()\n        dispose()\n        resolve()\n      } catch (err) {\n        if (!curRequestController.signal.aborted) {\n          // if we haven't aborted the request ourselves:\n          try {\n            // check if we need to retry:\n            const interval: any = onerror?.(err) ?? retryInterval\n            window.clearTimeout(retryTimer)\n            retryTimer = window.setTimeout(create, interval)\n            retryInterval *= retryScaler // exponential backoff\n            retryInterval = Math.min(retryInterval, retryMaxWaitMs)\n            retries++\n            if (retries >= retryMaxCount) {\n              dispatchSSE(RETRIES_FAILED, el, {})\n\n              // we should not retry anymore:\n              dispose()\n              // Max retries reached, check your server or network connection\n              reject('Max retries reached.')\n            } else {\n              console.error(\n                `Datastar failed to reach ${input.toString()} retrying in ${interval}ms.`,\n              )\n            }\n          } catch (innerErr) {\n            // we should not retry anymore:\n            dispose()\n            reject(innerErr)\n          }\n        }\n      }\n    }\n\n    create()\n  })\n}\n", "// Icon: material-symbols:delete-outline\n// Slug: Use a DELETE request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const DELETE: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'delete',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'DELETE', url, { ...args })\n  },\n}\n", "// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const GET: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'get',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'GET', url, { ...args })\n  },\n}\n", "// Icon: fluent:patch-24-filled\n// Slug: Use a PATCH request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const PATCH: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'patch',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'PATCH', url, { ...args })\n  },\n}\n", "// Icon: ri:signpost-fill\n// Slug: Use a POST request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const POST: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'post',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'POST', url, { ...args })\n  },\n}\n", "// Icon: material-symbols:arrows-input\n// Slug: Use a PUT request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const PUT: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'put',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'PUT', url, { ...args })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: tabler:file-type-js\n// Slug: Execute JavaScript using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultExecuteScriptAttributes,\n  DefaultExecuteScriptAutoRemove,\n  EventTypeExecuteScript,\n} from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { isBoolString } from '../../../../utils/text'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const ExecuteScript: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypeExecuteScript,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypeExecuteScript,\n      ({\n        autoRemove: autoRemoveRaw = `${DefaultExecuteScriptAutoRemove}`,\n        attributes: attributesRaw = DefaultExecuteScriptAttributes,\n        script,\n      }) => {\n        const autoRemove = isBoolString(autoRemoveRaw)\n        if (!script?.length) {\n          throw initErr('NoScriptProvided', ctx)\n        }\n        const scriptEl = document.createElement('script')\n        for (const attr of attributesRaw.split('\\n')) {\n          const pivot = attr.indexOf(' ')\n          const key = pivot ? attr.slice(0, pivot) : attr\n          const value = pivot ? attr.slice(pivot) : ''\n          scriptEl.setAttribute(key.trim(), value.trim())\n        }\n        scriptEl.text = script\n        document.head.appendChild(scriptEl)\n        if (autoRemove) {\n          scriptEl.remove()\n        }\n      },\n    )\n  },\n}\n", "import type { EventCallbackHandler, Modifiers } from \"../engine/types\"\n\nexport interface DocumentSupportingViewTransitionAPI {\n  startViewTransition(\n    updateCallback: () => Promise<void> | void,\n  ): IViewTransition\n}\n\nexport interface IViewTransition {\n  finished: Promise<void>\n  ready: Promise<void>\n  updateCallbackDone: Promise<void>\n  skipTransition(): void\n}\n\nexport const docWithViewTransitionAPI =\n  document as unknown as DocumentSupportingViewTransitionAPI\n  \nexport const supportsViewTransitions =\n  !!docWithViewTransitionAPI.startViewTransition\n\nexport function modifyViewTransition(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  if (mods.has('viewtransition') && supportsViewTransitions) {\n    const cb = callback // I hate javascript\n    callback = (...args: any[]) =>\n      document.startViewTransition(() => cb(...args))\n  }\n\n  return callback\n}", "// Authors: Delaney Gillilan\n// Icon: material-symbols:cloud-download\n// Slug: Merge fragments into the DOM using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultFragmentMergeMode,\n  EventTypeMergeFragments,\n  FragmentMergeModeAfter,\n  FragmentMergeModeAppend,\n  FragmentMergeModeBefore,\n  FragmentMergeModeInner,\n  FragmentMergeModeMorph,\n  FragmentMergeModeOuter,\n  FragmentMergeModePrepend,\n  FragmentMergeModeUpsertAttributes,\n} from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport {\n  type HTMLOrSVGElement,\n  type InitContext,\n  PluginType,\n  type WatcherPlugin,\n} from '../../../../engine/types'\nimport { walkDOM } from '../../../../utils/dom'\nimport { isBoolString } from '../../../../utils/text'\nimport {\n  docWithViewTransitionAPI,\n  supportsViewTransitions,\n} from '../../../../utils/view-transtions'\nimport { datastarSSEEventWatcher } from '../shared'\n\nconst DIV = 'div'\nconst VALUE = 'value'\nconst createEl = (tagName: string) => document.createElement(tagName)\nconst createDiv = () => createEl(DIV) as HTMLDivElement\nconst tagRaw = (tagName: string) => `<${tagName}></${tagName}>`\nconst elIDs = (el: Element) => [...el.querySelectorAll('[id]')]\nconst isElement = (el: Node) => el instanceof Element\nconst isTemplate = (el: Node) => el instanceof HTMLTemplateElement\nconst isInput = (el: Node) => el instanceof HTMLInputElement\nconst isTextArea = (el: Node) => el instanceof HTMLTextAreaElement\nconst isOption = (el: Node) => el instanceof HTMLOptionElement\n\nexport const MergeFragments: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypeMergeFragments,\n  onGlobalInit: async (ctx) => {\n    const fragmentContainer = createEl('template') as HTMLTemplateElement\n    datastarSSEEventWatcher(\n      EventTypeMergeFragments,\n      ({\n        fragments: fragmentsRaw = tagRaw(DIV),\n        selector = '',\n        mergeMode = DefaultFragmentMergeMode,\n        useViewTransition: useViewTransitionRaw = 'false',\n      }) => {\n        const useViewTransition = isBoolString(useViewTransitionRaw)\n\n        fragmentContainer.innerHTML = fragmentsRaw.trim()\n        for (const fragment of [...fragmentContainer.content.children]) {\n          if (!isElement(fragment)) {\n            throw initErr('NoFragmentsFound', ctx)\n          }\n\n          const selectorOrID = selector || `#${fragment.getAttribute('id')}`\n          const targets = document.querySelectorAll(selectorOrID)\n          if (!targets.length) {\n            throw initErr('NoTargetsFound', ctx, { selectorOrID })\n          }\n\n          if (useViewTransition && supportsViewTransitions) {\n            docWithViewTransitionAPI.startViewTransition(() =>\n              applyToTargets(\n                ctx,\n                mergeMode,\n                fragment as HTMLOrSVGElement,\n                targets,\n              ),\n            )\n          } else {\n            applyToTargets(\n              ctx,\n              mergeMode,\n              fragment as HTMLOrSVGElement,\n              targets,\n            )\n          }\n        }\n      },\n    )\n  },\n}\n\nfunction applyToTargets(\n  ctx: InitContext,\n  mergeMode: string,\n  fragment: HTMLOrSVGElement,\n  capturedTargets: NodeListOf<Element>,\n) {\n  for (const target of capturedTargets) {\n    // Clone the fragment to merge to avoid modifying the original and force browsers to merge the fragment into the DOM\n    const fragmentToMerge = fragment.cloneNode(true) as HTMLOrSVGElement\n\n    switch (mergeMode) {\n      case FragmentMergeModeMorph: {\n        // Morph the target element with the cloned fragment\n        morph(target, fragmentToMerge)\n\n        // Clean up and reapply all plugins in the merged fragment (a necessary evil!)\n        walkDOM(target, (el) => {\n          const cleanups = ctx.removals.get(el)\n          if (ctx.removals.delete(el)) {\n            for (const cleanup of cleanups!.values()) {\n              cleanup()\n            }\n            cleanups!.clear()\n          }\n          ctx.applyToElement(el)\n        })\n        break\n      }\n      case FragmentMergeModeInner:\n        // Replace the contents of the target element with the outer HTML of the response\n        target.innerHTML = fragmentToMerge.outerHTML\n        break\n      case FragmentMergeModeOuter:\n        // Replace the entire target element with the response\n        target.replaceWith(fragmentToMerge)\n        break\n      case FragmentMergeModePrepend:\n        // Insert the response before the first child of the target element\n        target.prepend(fragmentToMerge)\n        break\n      case FragmentMergeModeAppend:\n        // Insert the response after the last child of the target element\n        target.append(fragmentToMerge)\n        break\n      case FragmentMergeModeBefore:\n        // Insert the response before the target element\n        target.before(fragmentToMerge)\n        break\n      case FragmentMergeModeAfter:\n        // Insert the response after the target element\n        target.after(fragmentToMerge)\n        break\n      case FragmentMergeModeUpsertAttributes:\n        // Upsert the attributes of the target element\n        for (const attrName of fragmentToMerge.getAttributeNames()) {\n          const value = fragmentToMerge.getAttribute(attrName)!\n          target.setAttribute(attrName, value)\n        }\n        break\n      default:\n        throw initErr('InvalidMergeMode', ctx, { mergeMode })\n    }\n  }\n}\n\nconst ctxPantry = createDiv()\nctxPantry.hidden = true\n\nlet ctxTarget: Element\nconst ctxIdMap = new Map<Node, Set<string>>()\nconst ctxPersistentIds = new Set<string>()\n\n// @ts-ignore\nexport const moveBeforeSupported = ctxPantry.moveBefore !== undefined\n\nfunction morph(oldNode: Element, newContent: HTMLOrSVGElement): Node[] {\n  const normalizedNode = createDiv() as HTMLOrSVGElement\n  normalizedNode.append(newContent as Node)\n  const newIdElements = elIDs(normalizedNode)\n\n  // all elements with an ID contained within the root element and its descendants\n  const oldIdElements = elIDs(oldNode)\n  if (oldNode.id) {\n    oldIdElements.push(oldNode)\n  }\n\n  // Computes the set of ids that persist between the two contents excluding duplicates\n  const duplicateIds = new Set<string>()\n\n  const oldIdTagNameMap = new Map<string, string>()\n  for (const { id, tagName } of oldIdElements) {\n    if (oldIdTagNameMap.has(id)) {\n      duplicateIds.add(id)\n    } else {\n      oldIdTagNameMap.set(id, tagName)\n    }\n  }\n\n  ctxPersistentIds.clear()\n  for (const { id, tagName } of newIdElements) {\n    if (ctxPersistentIds.has(id)) {\n      duplicateIds.add(id)\n    } else if (oldIdTagNameMap.get(id) === tagName) {\n      ctxPersistentIds.add(id)\n    }\n    // skip if tag types mismatch because its not possible to morph one tag into another\n  }\n\n  for (const id of duplicateIds) {\n    ctxPersistentIds.delete(id)\n  }\n\n  // Computes a map of nodes to all ids contained within that node (inclusive of the node).\n  // This map can be used to ask if two nodes have intersecting sets of ids,\n  // which allows for a looser definition of \"matching\" than tradition id matching,\n  // and allows child nodes to contribute to a parent nodes matching.\n  // const idMap = new Map<Node, Set<string>>()\n  ctxIdMap.clear()\n  populateIdMapWithTree(oldNode.parentElement, oldIdElements)\n  populateIdMapWithTree(normalizedNode, newIdElements)\n\n  document.body.insertAdjacentElement('afterend', ctxPantry)\n\n  ctxTarget = oldNode\n\n  // Morph just the outerHTML of the oldNode to the newContent\n  // We have to be careful because the oldNode could have siblings which need to be untouched\n  // oldParent can be a document or documentFragment but we can treat these as Element\n  const oldParent = oldNode.parentNode as Element\n\n  // store start and end points so we can find inbetween nodes to return later\n  // as we can avoid returning before or after siblings\n  const beforeStartPoint = oldNode.previousSibling\n  const endPoint = oldNode.nextSibling\n\n  morphChildren(\n    oldParent,\n    normalizedNode,\n    // these two optional params are the secret sauce\n    oldNode, // start point for iteration\n    endPoint, // end point for iteration\n  )\n\n  const nodes: Node[] = []\n\n  // return array from the first node added to before the last node\n  let cursor = beforeStartPoint?.nextSibling || oldParent.firstChild\n  while (cursor && cursor !== endPoint) {\n    nodes.push(cursor)\n    cursor = cursor.nextSibling\n  }\n  ctxPantry.remove()\n  return nodes\n}\n\n// This is the core algorithm for matching up children.\n// The idea is to use id sets to try to match up nodes as faithfully as possible.\n// We greedily match, which allows us to keep the algorithm fast,\n// but by using id sets, we are able to better match up with content deeper in the DOM.\nfunction morphChildren(\n  oldParent: Element, // the old content that we are merging the new content into\n  newParent: Element, // the parent element of the new content\n  insertionPoint: Node | null = null, // // the point in the DOM we start morphing at (defaults to first child)\n  endPoint: Node | null = null, // the point in the DOM we stop morphing at (defaults to after last child)\n) {\n  // normalize\n  if (isTemplate(oldParent) && isTemplate(newParent)) {\n    // we can pretend the DocumentFragment is an Element\n    oldParent = oldParent.content as unknown as Element\n    newParent = newParent.content as unknown as Element\n  }\n  insertionPoint ??= oldParent.firstChild\n\n  // run through all the new content\n  for (const newChild of newParent.childNodes) {\n    // once we reach the end of the old parent content skip to the end and insert the rest\n    if (insertionPoint && insertionPoint !== endPoint) {\n      const bestMatch = findBestMatch(newChild, insertionPoint, endPoint)\n      if (bestMatch) {\n        // if the node to morph is not at the insertion point then remove/move up to it\n        if (bestMatch !== insertionPoint) {\n          let cursor: Node | null = insertionPoint\n          // Remove nodes between the start and end nodes\n          while (cursor && cursor !== bestMatch) {\n            const tempNode = cursor\n            cursor = cursor.nextSibling\n            removeNode(tempNode)\n          }\n        }\n        morphNode(bestMatch, newChild)\n        insertionPoint = bestMatch.nextSibling\n        continue\n      }\n    }\n\n    // if the matching node is elsewhere in the original content\n    if (isElement(newChild) && ctxPersistentIds.has(newChild.id)) {\n      // move it and all its children here and morph, will always be found\n      // Search for an element by id within the document and pantry, and move it using moveBefore.\n      const ncID = newChild.id\n      const qsTemplate = `[id=\"${ncID}\"]`\n      const qs = (el: Element) => el.querySelector(qsTemplate)\n      const movedChild = ((ctxTarget.id === ncID && ctxTarget) ||\n        qs(ctxTarget) ||\n        qs(ctxPantry))!\n\n      // Removes an element from its ancestors' id maps.\n      // This is needed when an element is moved from the \"future\" via `moveBeforeId`.\n      // Otherwise, its erstwhile ancestors could be mistakenly moved to the pantry rather than being deleted,\n      // preventing their removal hooks from being called.\n      let current = movedChild\n      while ((current = current.parentNode as Element)) {\n        const idSet = ctxIdMap.get(current)\n        if (idSet) {\n          idSet.delete(movedChild.id)\n          if (!idSet.size) {\n            ctxIdMap.delete(current)\n          }\n        }\n      }\n\n      moveBefore(oldParent, movedChild, insertionPoint)\n      morphNode(movedChild, newChild)\n      insertionPoint = movedChild.nextSibling\n      continue\n    }\n\n    // This performs the action of inserting a new node while handling situations where the node contains\n    // elements with persistent ids and possible state info we can still preserve by moving in and then morphing\n    if (ctxIdMap.has(newChild)) {\n      // node has children with ids with possible state so create a dummy elt of same type and apply full morph algorithm\n      const newEmptyChild = createEl((newChild as Element).tagName)\n      oldParent.insertBefore(newEmptyChild, insertionPoint)\n      morphNode(newEmptyChild, newChild)\n      return newEmptyChild\n    }\n    // optimisation: no id state to preserve so we can just insert a clone of the newChild and its descendants\n    const insertedNode = document.importNode(newChild, true) // importNode to not mutate newParent\n    oldParent.insertBefore(insertedNode, insertionPoint)\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint && insertionPoint !== endPoint) {\n    const tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling\n    removeNode(tempNode)\n  }\n}\n\n// Scans forward from the startPoint to the endPoint looking for a match for the node.\n// It looks for an id set match first, then a soft match.\n// We abort softmatching if we find two future soft matches, to reduce churn.\nfunction findBestMatch(\n  node: Node,\n  startPoint: Node | null,\n  endPoint: Node | null,\n): Node | null {\n  let bestMatch = null\n  let nextSibling = node.nextSibling\n  let siblingSoftMatchCount = 0\n  let displaceMatchCount = 0\n\n  // max id matches we are willing to displace in our search\n  const nodeMatchCount = ctxIdMap.get(node)?.size || 0\n\n  let cursor = startPoint\n  while (cursor && cursor !== endPoint) {\n    // soft matching is a prerequisite for id set matching\n    if (isSoftMatch(cursor, node)) {\n      let isIdSetMatch = false\n      const oldSet = ctxIdMap.get(cursor)\n      const newSet = ctxIdMap.get(node)\n\n      if (newSet && oldSet) {\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            isIdSetMatch = true\n            break\n          }\n        }\n      }\n\n      if (isIdSetMatch) {\n        return cursor // found an id set match, we're done!\n      }\n\n      // we haven't yet saved a soft match fallback\n      // the current soft match will hard match something else in the future, leave it\n      if (!bestMatch && !ctxIdMap.has(cursor)) {\n        // optimization: if node can't id set match, we can just return the soft match immediately\n        if (!nodeMatchCount) {\n          return cursor\n        }\n        // save this as the fallback if we get through the loop without finding a hard match\n        bestMatch = cursor\n      }\n    }\n    // check for ids we may be displaced when matching\n    displaceMatchCount += ctxIdMap.get(cursor)?.size || 0\n    if (displaceMatchCount > nodeMatchCount) {\n      // if we are going to displace more ids than the node contains then\n      // we do not have a good candidate for an id match, so return\n      break\n    }\n\n    if (bestMatch === null && nextSibling && isSoftMatch(cursor, nextSibling)) {\n      // The next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling\n\n      // If there are two future soft matches, block soft matching for this node to allow\n      // future siblings to soft match. This is to reduce churn in the DOM when an element\n      // is prepended.\n      if (siblingSoftMatchCount >= 2) {\n        bestMatch = undefined\n      }\n    }\n\n    // if the current node contains active element, stop looking for better future matches,\n    // because if one is found, this node will be moved to the pantry, reparenting it and thus losing focus\n    if (cursor.contains(document.activeElement)) break\n\n    cursor = cursor.nextSibling\n  }\n\n  return bestMatch || null\n}\n\nfunction isSoftMatch(oldNode: Node, newNode: Node): boolean {\n  // ok to cast: if one is not element, `id` and `tagName` will be null and we'll just compare that.\n  const oldElt = oldNode as Element\n  const newElt = newNode as Element\n\n  return (\n    oldElt.nodeType === newElt.nodeType &&\n    oldElt.tagName === newElt.tagName &&\n    // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.\n    // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n    // its not persistent, and new nodes can't have any hidden state.\n    (!oldElt.id || oldElt.id === newElt.id)\n  )\n}\n\n// Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n// - Persistent nodes will be moved to the pantry for later reuse\n// - Other nodes will have their hooks called, and then are removed\nfunction removeNode(node: Node) {\n  // are we going to id set match this later?\n  if (ctxIdMap.has(node)) {\n    // skip callbacks and move to pantry\n    moveBefore(ctxPantry, node, null)\n  } else {\n    // remove for realsies\n    node.parentNode?.removeChild(node)\n  }\n}\n\n// hasMoveBeforeSupport type\ntype PossibleMoveBeforeSupport = Element & {\n  moveBefore?: (element: Node, beforeNode: Node | null) => void\n}\n\n// Moves an element before another element within the same parent.\n// Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n// This is essentialy a forward-compat wrapper.\nfunction moveBefore(\n  parentNode: PossibleMoveBeforeSupport, // the parent node containing the after element\n  element: Node, // the element to be moved\n  after: Node | null = null, // the reference node to insert `element` before. If `null`, `element` is appended as the last child\n) {\n  if (moveBeforeSupported) {\n    parentNode.moveBefore!(element, after)\n  } else {\n    parentNode.insertBefore(element, after)\n  }\n}\n\nfunction morphNode(\n  oldNode: Node, // root node to merge content into\n  newContent: Node, // new content to merge\n) {\n  // syncs the oldNode to the newNode, copying over all attributes and\n  // inner element state from the newNode to the oldNode\n  const type = newContent.nodeType\n\n  const oldElt = oldNode as Element\n  const newElt = newContent as Element\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    const oldAttributes = oldElt.attributes\n    const newAttributes = newElt.attributes\n    for (const newAttribute of newAttributes) {\n      if (oldElt.getAttribute(newAttribute.name) !== newAttribute.value) {\n        oldElt.setAttribute(newAttribute.name, newAttribute.value)\n      }\n    }\n    // iterate backwards to avoid skipping over items when a delete occurs\n    for (let i = oldAttributes.length - 1; 0 <= i; i--) {\n      const oldAttribute = oldAttributes[i]\n\n      // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n      // e.g. custom element attribute callbacks can remove other attributes\n      if (!oldAttribute) continue\n\n      if (!newElt.hasAttribute(oldAttribute.name)) {\n        oldElt.removeAttribute(oldAttribute.name)\n      }\n    }\n\n    //  many bothans died to bring us information:\n    //  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n    //  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n    if (isInput(oldElt) && isInput(newElt) && newElt.type !== 'file') {\n      const newValue = newElt.value\n      const oldValue = oldElt.value\n\n      // sync boolean attributes\n      syncBooleanAttribute(oldElt, newElt, 'checked')\n      syncBooleanAttribute(oldElt, newElt, 'disabled')\n\n      const hasBind = Object.keys(newElt.dataset || {}).some((key) =>\n        key.startsWith('bind'),\n      )\n\n      if (!hasBind) {\n        if (!newElt.hasAttribute(VALUE)) {\n          oldElt.value = ''\n          oldElt.removeAttribute(VALUE)\n        } else if (oldValue !== newValue) {\n          oldElt.setAttribute(VALUE, newValue)\n          oldElt.value = newValue\n        }\n      }\n    } else if (isOption(oldElt) && isOption(newElt)) {\n      syncBooleanAttribute(oldElt, newElt, 'selected')\n    } else if (isTextArea(oldElt) && isTextArea(newElt)) {\n      const newValue = newElt.value\n      const oldValue = oldElt.value\n\n      if (newValue !== oldValue) {\n        oldElt.value = newValue\n      }\n      if (oldElt.firstChild && oldElt.firstChild.nodeValue !== newValue) {\n        oldElt.firstChild.nodeValue = newValue\n      }\n    }\n  }\n\n  if (type === 8 /* comment */ || type === 3 /* text */) {\n    if (oldNode.nodeValue !== newContent.nodeValue) {\n      oldNode.nodeValue = newContent.nodeValue\n    }\n  }\n\n  if (oldElt.innerHTML !== newElt.innerHTML) {\n    // newContent can be an element here because .firstChild will be null\n    morphChildren(oldElt, newElt)\n  }\n  return oldNode\n}\n\nfunction syncBooleanAttribute(\n  writeTo: Element,\n  readFrom: Element,\n  attributeName: string,\n) {\n  const readFromAny = readFrom as any\n  const writeToAny = writeTo as any\n  const newLiveValue = readFromAny[attributeName]\n  const oldLiveValue = writeToAny[attributeName]\n  if (newLiveValue !== oldLiveValue) {\n    // update attribute's associated DOM property\n    writeToAny[attributeName] = readFromAny[attributeName]\n    if (newLiveValue) {\n      // https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML\n      // this is the correct way to set a boolean attribute to \"true\"\n      writeTo.setAttribute(attributeName, '')\n    } else {\n      writeTo.removeAttribute(attributeName)\n    }\n  }\n}\n\n// A bottom-up algorithm that populates a map of Element -> IdSet.\n// The idSet for a given element is the set of all IDs contained within its subtree.\n// As an optimzation, we filter these IDs through the given list of persistent IDs,\n// because we don't need to bother considering IDed elements that won't be in the new content.\nfunction populateIdMapWithTree(\n  root: Element | null,\n  elements: Element[] | NodeListOf<Element>,\n) {\n  for (const elt of elements) {\n    if (ctxPersistentIds.has(elt.id)) {\n      let current: Element | null = elt\n      // walk up the parent hierarchy of that element, adding the id of element to the parent's id set\n      while (current && current !== root) {\n        let idSet = ctxIdMap.get(current)\n        // if the id set doesn't exist, create it and insert it in the map\n        if (!idSet) {\n          idSet = new Set()\n          ctxIdMap.set(current, idSet)\n        }\n        idSet.add(elt.id)\n        current = current.parentElement\n      }\n    }\n  }\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Merge signals using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultMergeSignalsOnlyIfMissing,\n  EventTypeMergeSignals,\n} from '../../../../engine/consts'\nimport { mergeDeps } from '../../../../engine/signals'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { isBoolString, jsStrToObject } from '../../../../utils/text'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const MergeSignals: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypeMergeSignals,\n  onGlobalInit: async ({ batch }) => {\n    datastarSSEEventWatcher(\n      EventTypeMergeSignals,\n      ({\n        signals: raw = '{}',\n        onlyIfMissing: onlyIfMissingRaw = `${DefaultMergeSignalsOnlyIfMissing}`,\n      }) => {\n        const onlyIfMissing = isBoolString(onlyIfMissingRaw)\n        const rawObj = jsStrToObject(raw)\n        batch(() => mergeDeps(rawObj, onlyIfMissing))\n      },\n    )\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Remove fragments from the DOM using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultFragmentsUseViewTransitions,\n  EventTypeRemoveFragments,\n} from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { isBoolString } from '../../../../utils/text'\nimport {\n  docWithViewTransitionAPI,\n  supportsViewTransitions,\n} from '../../../../utils/view-transtions'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const RemoveFragments: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypeRemoveFragments,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypeRemoveFragments,\n      ({\n        selector,\n        useViewTransition:\n          useViewTransitionRaw = `${DefaultFragmentsUseViewTransitions}`,\n      }) => {\n        if (!selector.length) {\n          throw initErr('NoSelectorProvided', ctx)\n        }\n\n        const useViewTransition = isBoolString(useViewTransitionRaw)\n        const removeTargets = document.querySelectorAll(selector)\n\n        const applyToTargets = () => {\n          for (const target of removeTargets) {\n            target.remove()\n          }\n        }\n\n        if (useViewTransition && supportsViewTransitions) {\n          docWithViewTransitionAPI.startViewTransition(() => applyToTargets())\n        } else {\n          applyToTargets()\n        }\n      },\n    )\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Remove signals using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { EventTypeRemoveSignals } from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport { removeDeps } from '../../../../engine/signals'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const RemoveSignals: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypeRemoveSignals,\n  onGlobalInit: async (ctx) => {\n    const { batch } = ctx\n    datastarSSEEventWatcher(\n      EventTypeRemoveSignals,\n      ({ paths: pathsRaw = '' }) => {\n        const paths = pathsRaw.split('\\n').map((p) => p.trim())\n        if (!paths?.length) {\n          throw initErr('NoPathsProvided', ctx)\n        }\n        batch(() => {\n          removeDeps(...paths)\n        })\n      },\n    )\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:edit-attributes-outline\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../engine/types'\nimport { kebab } from '../../../utils/text'\n\nexport const Attr: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'attr',\n  valReq: Requirement.Must,\n  onLoad: ({ el, key, genRX, computed, effect }) => {\n    const { deps, rxFn } = genRX()\n    if (key === '') {\n      const c = computed<Record<string, any>>(deps, rxFn)\n      return effect([c], async (binds: Record<string, any>) => {\n        for (const [key, val] of Object.entries(binds)) {\n          if (val === false) {\n            el.removeAttribute(key)\n          } else {\n            el.setAttribute(key, val)\n          }\n        }\n      })\n    }\n\n    // Attributes are always kebab-case\n    key = kebab(key)\n\n    const c = computed(deps, rxFn)\n    return effect([c], async (value) => {\n      let v: string\n      if (typeof value === 'string') {\n        v = value\n      } else {\n        v = JSON.stringify(value)\n      }\n      if (!v || v === 'false' || v === 'null' || v === 'undefined') {\n        el.removeAttribute(key)\n      } else {\n        el.setAttribute(key, v)\n      }\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: akar-icons:link-chain\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport { runtimeErr } from '../../../engine/errors'\nimport { depValue, setDepValue, upsertIfMissing } from '../../../engine/signals'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../engine/types'\nimport { modifyCasing, trimDollarSignPrefix } from '../../../utils/text'\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst updateEvents = ['change', 'input', 'keydown']\n\nexport const Bind: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'bind',\n  keyReq: Requirement.Exclusive,\n  valReq: Requirement.Exclusive,\n  onLoad: (ctx) => {\n    const { el, key, mods, value, effect, batch } = ctx\n    const input = el as HTMLInputElement\n    const signalName = key\n      ? modifyCasing(key, mods)\n      : trimDollarSignPrefix(value)\n\n    const tnl = el.tagName.toLowerCase()\n    const isInput = tnl.includes('input')\n    const isSelect = tnl.includes('select')\n    const type = el.getAttribute('type')\n    const hasValueAttribute = el.hasAttribute('value')\n\n    let signalDefault: string | boolean | number | File | Array<string> = ''\n    const isCheckbox = isInput && type === 'checkbox'\n    if (isCheckbox) {\n      signalDefault = hasValueAttribute ? '' : false\n    }\n    const isNumber = isInput && type === 'number'\n    if (isNumber) {\n      signalDefault = 0\n    }\n    const isRadio = isInput && type === 'radio'\n    if (isRadio) {\n      const name = el.getAttribute('name')\n      if (!name?.length) {\n        el.setAttribute('name', signalName)\n      }\n    }\n    // Can't set a default value for a file input, yet\n    const isFile = isInput && type === 'file'\n\n    const { dep, inserted } = batch(() => {\n      return upsertIfMissing(signalName, signalDefault)\n    })\n\n    let arrayIndex = -1\n    if (Array.isArray(dep.value)) {\n      if (el.getAttribute('name') === null) {\n        el.setAttribute('name', signalName)\n      }\n      arrayIndex = [\n        ...document.querySelectorAll(`[name=\"${signalName}\"]`),\n      ].findIndex((el) => el === ctx.el)\n    }\n    const isArray = arrayIndex >= 0\n\n    const signalArray = () => [...(depValue(signalName) as unknown as any[])]\n\n    const setElementFromSignal = () => {\n      let value = depValue(signalName)\n      if (isArray && !isSelect) {\n        // May be undefined if the array is shorter than the index\n        value = (value as any)[arrayIndex] || signalDefault\n      }\n      const stringValue = `${value}`\n      if (isCheckbox || isRadio) {\n        if (typeof value === 'boolean') {\n          input.checked = value\n        } else {\n          input.checked = stringValue === input.value\n        }\n      } else if (isSelect) {\n        const select = el as HTMLSelectElement\n        if (select.multiple) {\n          if (!isArray) {\n            throw runtimeErr('BindSelectMultiple', ctx)\n          }\n          for (const opt of select.options) {\n            if (opt?.disabled) continue\n            const incoming = isNumber ? Number(opt.value) : opt.value\n            opt.selected = (value as unknown as any[]).includes(incoming)\n          }\n        } else {\n          select.value = stringValue\n        }\n      } else if (isFile) {\n        // File input reading from a signal is not supported\n      } else if ('value' in el) {\n        el.value = stringValue\n      } else {\n        el.setAttribute('value', stringValue)\n      }\n    }\n\n    const setSignalFromElement = async () => {\n      let currentValue = depValue(signalName)\n      if (isArray) {\n        // Push as many default signal values onto the array as necessary to reach the index\n        const currentArray = currentValue as unknown as any[]\n        while (arrayIndex >= currentArray.length) {\n          currentArray.push(signalDefault)\n        }\n        currentValue = currentArray[arrayIndex] || signalDefault\n      }\n\n      const update = (signalName: string, value: any) => {\n        let newValue = value\n        if (isArray && !isSelect && !isFile) {\n          newValue = signalArray()\n          newValue[arrayIndex] = value\n        }\n        setDepValue(signalName, newValue)\n      }\n\n      // Files are a special flower\n      if (isFile) {\n        const files = [...(input?.files || [])]\n        const allContents: string[] = []\n        const allMimes: string[] = []\n        const allNames: string[] = []\n\n        await Promise.all(\n          files.map((f) => {\n            return new Promise<void>((resolve) => {\n              const reader = new FileReader()\n              reader.onload = () => {\n                if (typeof reader.result !== 'string') {\n                  throw runtimeErr('InvalidFileResultType', ctx, {\n                    resultType: typeof reader.result,\n                  })\n                }\n                const match = reader.result.match(dataURIRegex)\n                if (!match?.groups) {\n                  throw runtimeErr('InvalidDataUri', ctx, {\n                    result: reader.result,\n                  })\n                }\n                allContents.push(match.groups.contents)\n                allMimes.push(match.groups.mime)\n                allNames.push(f.name)\n              }\n              reader.onloadend = () => resolve(void 0)\n              reader.readAsDataURL(f)\n            })\n          }),\n        )\n        batch(() => {\n          update(signalName, allContents)\n          update(`${signalName}Mimes`, allMimes)\n          update(`${signalName}Names`, allNames)\n        })\n        return\n      }\n\n      const value = input.value || ''\n      let newValue: any\n\n      if (isCheckbox) {\n        const checked =\n          input.checked || input.getAttribute('checked') === 'true'\n\n        // We must check for an attribute value because a checked value defaults to `on`.\n        if (hasValueAttribute) {\n          newValue = checked ? value : ''\n        } else {\n          newValue = checked\n        }\n      } else if (isSelect) {\n        const select = el as HTMLSelectElement\n        const selectedOptions = [...select.selectedOptions]\n        if (isArray) {\n          newValue = selectedOptions\n            .filter((opt) => opt.selected)\n            .map((opt) => opt.value)\n        } else {\n          newValue = selectedOptions[0]?.value || signalDefault\n        }\n      } else if (typeof currentValue === 'boolean') {\n        newValue = Boolean(value)\n      } else if (typeof currentValue === 'number') {\n        newValue = Number(value)\n      } else {\n        newValue = value || ''\n      }\n\n      batch(() => {\n        update(signalName, newValue)\n      })\n    }\n\n    // If the signal was inserted, attempt to set the the signal value from the element.\n    if (inserted) {\n      setSignalFromElement()\n    }\n\n    for (const event of updateEvents) {\n      el.addEventListener(event, setSignalFromElement)\n    }\n\n    /*\n     * The signal value needs to be updated after the \"pageshow\" event.\n     * Sometimes, the browser might populate inputs with previous values\n     * when navigating between pages using the back/forward navigation.\n     *\n     * For more information, read about bfcache:\n     * https://web.dev/articles/bfcache\n     */\n    const onPageshow = (ev: PageTransitionEvent) => {\n      if (!ev.persisted) return\n      setSignalFromElement()\n    }\n    window.addEventListener('pageshow', onPageshow)\n\n    const reset = effect([dep], () => setElementFromSignal())\n    return () => {\n      reset()\n      for (const event of updateEvents) {\n        el.removeEventListener(event, setSignalFromElement)\n      }\n      window.removeEventListener('pageshow', onPageshow)\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: ic:baseline-format-paint\n// Slug: Add or remove classes from an element reactively\n// Description: This action adds or removes classes from an element reactively based on the expression provided. The expression should be an object where the keys are the class names and the values are booleans. If the value is true, the class is added. If the value is false, the class is removed.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../engine/types'\nimport { kebab, modifyCasing } from '../../../utils/text'\n\nexport const Class: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'class',\n  valReq: Requirement.Must,\n  onLoad: ({ el, key, mods, genRX, computed, effect }) => {\n    const cl = el.classList\n    const { deps, rxFn } = genRX()\n    const c = computed<Record<string, boolean> | boolean>(deps, rxFn)\n    return effect([c], (value: Record<string, boolean> | boolean) => {\n      if (key === '') {\n        const classes = value as Record<string, boolean>\n        for (const [k, v] of Object.entries(classes)) {\n          const classNames = k.split(/\\s+/)\n          if (v) {\n            cl.add(...classNames)\n          } else {\n            cl.remove(...classNames)\n          }\n        }\n      } else {\n        // Default to kebab-case and allow modifying\n        let className = kebab(key)\n        className = modifyCasing(className, mods)\n\n        const shouldInclude = value as boolean\n        if (shouldInclude) {\n          cl.add(className)\n        } else {\n          cl.remove(className)\n        }\n      }\n    })\n  },\n}\n", "// Icon: material-symbols:network-wifi\n// Slug: Sets the indicator signal used when fetching data via SSE\n// Description: must be a valid signal name\n\nimport { runtimeErr } from '../../../engine/errors'\nimport { Signal, upsertIfMissing } from '../../../engine/signals'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../engine/types'\nimport { modifyCasing, trimDollarSignPrefix } from '../../../utils/text'\nimport {\n  DATASTAR_SSE_EVENT,\n  type DatastarSSEEvent,\n  FINISHED,\n  STARTED,\n} from '../backend/shared'\n\nexport const Indicator: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'indicator',\n  keyReq: Requirement.Exclusive,\n  valReq: Requirement.Exclusive,\n  onLoad: (ctx) => {\n    const { el, key, mods, value, batch } = ctx\n    const signalName = key\n      ? modifyCasing(key, mods)\n      : trimDollarSignPrefix(value)\n    const { dep } = batch(() => {\n      return upsertIfMissing(signalName, false)\n    })\n    if (!(dep instanceof Signal)) {\n      throw runtimeErr('not_signal', ctx, { signalName })\n    }\n    const watcher = ((event: CustomEvent<DatastarSSEEvent>) => {\n      const { type, el: elt } = event.detail\n      if (elt !== el) {\n        return\n      }\n      switch (type) {\n        case STARTED:\n          dep.value = true\n          break\n        case FINISHED:\n          dep.value = false\n          break\n      }\n    }) as EventListener\n\n    document.addEventListener(DATASTAR_SSE_EVENT, watcher)\n\n    return () => {\n      dep.value = false\n      document.removeEventListener(DATASTAR_SSE_EVENT, watcher)\n    }\n  },\n}\n", "// Authors: Ben Croker\n// Icon: tabler:typography\n// Slug: Set the text content of an element to a reactive JSON stringified version of all signals\n// Description: This attribute sets the text content of an element to a reactive JSON stringified version of all signals.\n\nimport { runtimeErr } from '../../../engine/errors'\nimport { json } from '../../../engine/signals'\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_EVENT,\n  PluginType,\n  Requirement,\n} from '../../../engine/types'\n\nexport const JsonSignals: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'jsonSignals',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Denied,\n  onLoad: (ctx) => {\n    const { el } = ctx\n\n    if (!(el instanceof HTMLElement)) {\n      runtimeErr('JsonSignalsInvalidElement', ctx)\n    }\n\n    const callback = () => {\n      el.textContent = json(true)\n    }\n\n    callback()\n\n    document.addEventListener(DATASTAR_SIGNAL_EVENT, callback)\n\n    return () => {\n      document.removeEventListener(DATASTAR_SIGNAL_EVENT, callback)\n    }\n  },\n}\n", "export function tagToMs(args: Set<string>) {\n  if (!args || args.size <= 0) return 0\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return Number(arg.replace('ms', ''))\n    }\n    if (arg.endsWith('s')) {\n      return Number(arg.replace('s', '')) * 1000\n    }\n    try {\n      return Number.parseFloat(arg)\n    } catch (e) {}\n  }\n  return 0\n}\n\nexport function tagHas(tags: Set<string>, tag: string, defaultValue = false) {\n  if (!tags) return defaultValue\n  return tags.has(tag.toLowerCase())\n}\n", "import type { EventCallbackHandler, Modifiers } from \"../engine/types\"\nimport { tagHas, tagToMs } from \"./tags\"\n\nexport function delay(\n  callback: EventCallbackHandler,\n  wait: number,\n): EventCallbackHandler {\n  return (...args: any[]) => {\n    setTimeout(() => {\n      callback(...args)\n    }, wait)\n  }\n}\n\nexport function debounce(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = false,\n  trailing = true,\n): EventCallbackHandler {\n  let timer = -1\n\n  const resetTimer = () => timer && clearTimeout(timer)\n\n  return (...args: any[]) => {\n    resetTimer()\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      resetTimer()\n    }, wait)\n  }\n}\n\nexport function throttle(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = true,\n  trailing = false,\n): EventCallbackHandler {\n  let waiting = false\n\n  return (...args: any[]) => {\n    if (waiting) return\n\n    if (leading) {\n      callback(...args)\n    }\n\n    waiting = true\n    setTimeout(() => {\n      waiting = false\n      if (trailing) {\n        callback(...args)\n      }\n    }, wait)\n  }\n}\n\nexport function modifyTiming(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  const delayArgs = mods.get('delay')\n  if (delayArgs) {\n    const wait = tagToMs(delayArgs)\n    callback = delay(callback, wait)\n  }\n\n  const debounceArgs = mods.get('debounce')\n  if (debounceArgs) {\n    const wait = tagToMs(debounceArgs)\n    const leading = tagHas(debounceArgs, 'leading', false)\n    const trailing = !tagHas(debounceArgs, 'notrail', false)\n    callback = debounce(callback, wait, leading, trailing)\n  }\n\n  const throttleArgs = mods.get('throttle')\n  if (throttleArgs) {\n    const wait = tagToMs(throttleArgs)\n    const leading = !tagHas(throttleArgs, 'noleading', false)\n    const trailing = tagHas(throttleArgs, 'trail', false)\n    callback = throttle(callback, wait, leading, trailing)\n  }\n\n  return callback\n}", "// Authors: Delaney Gillilan\n// Icon: material-symbols:mail\n// Slug: Add an event listener to an element\n// Description: This plugin adds an event listener to an element. The event listener can be triggered by a variety of events, such as clicks, keypresses, and more. The event listener can also be set to trigger only once, or to be passive or capture. The event listener can also be debounced or throttled. The event listener can also be set to trigger only when the event target is outside the element.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../engine/types'\nimport { kebab, modifyCasing } from '../../../utils/text'\nimport { modifyTiming } from '../../../utils/timing'\nimport { modifyViewTransition } from '../../../utils/view-transtions'\nimport { DATASTAR_SSE_EVENT } from '../backend/shared'\n\nexport const On: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'on',\n  keyReq: Requirement.Must,\n  valReq: Requirement.Must,\n  argNames: ['evt'],\n  onLoad: (ctx) => {\n    const { el, key, mods, genRX, evalRX } = ctx\n\n    let target: Element | Window | Document = el\n    if (mods.has('window')) target = window\n\n    const { dm, deps, rxFn } = genRX()\n\n    let callback = (evt?: Event) => {\n      if (evt) {\n        if (mods.has('prevent')) {\n          evt.preventDefault()\n        }\n\n        if (mods.has('stop')) {\n          evt.stopPropagation()\n        }\n\n        // Return if not a trusted event, not a custom event and no `trust` modifier exists\n        if (!(evt.isTrusted || evt instanceof CustomEvent || mods.has('trust'))) {\n          return\n        }\n\n        ctx.evt = evt\n      }\n      \n      evalRX(rxFn, dm, deps, evt)\n    }\n\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n\n    const evtListOpts: AddEventListenerOptions = {\n      capture: false,\n      passive: false,\n      once: false,\n    }\n    if (mods.has('capture')) evtListOpts.capture = true\n    if (mods.has('passive')) evtListOpts.passive = true\n    if (mods.has('once')) evtListOpts.once = true\n\n    const testOutside = mods.has('outside')\n    if (testOutside) {\n      target = document\n      const cb = callback\n      callback = (evt?: Event) => {\n        const targetHTML = evt?.target as HTMLElement\n        if (!el.contains(targetHTML)) {\n          cb(evt)\n        }\n      }\n    }\n\n    // Default to kebab-case and allow modifying\n    let eventName = kebab(key)\n    eventName = modifyCasing(eventName, mods)\n\n    // Listen for Datastar SSE events on the document\n    if (eventName === DATASTAR_SSE_EVENT) {\n      target = document\n    } \n    \n    // Prevent default on form submit events\n    if (el instanceof HTMLFormElement && eventName === 'submit') {\n      const cb = callback\n      callback = (evt?: Event) => {\n        evt?.preventDefault()\n        cb(evt)\n      }\n    }\n\n    target.addEventListener(eventName, callback, evtListOpts)\n\n    return () => {\n      target.removeEventListener(eventName, callback)\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi-light:vector-intersection\n// Slug: Runs an expression when an element intersects with the viewport\n// Description: An attribute that runs an expression when an element intersects with the viewport.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../engine/types'\nimport { modifyTiming } from '../../../utils/timing'\nimport { modifyViewTransition } from '../../../utils/view-transtions'\n\nconst once = new WeakSet<HTMLOrSVGElement>()\n\nexport const OnIntersect: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'onIntersect',\n  keyReq: Requirement.Denied,\n  onLoad: ({ el, mods, genRX, evalRX }) => {\n    const { dm, deps, rxFn } = genRX()\n    let callback = () => evalRX(rxFn, dm, deps)\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n\n    const options = { threshold: 0 }\n    if (mods.has('full')) {\n      options.threshold = 1\n    } else if (mods.has('half')) {\n      options.threshold = 0.5\n    }\n\n    const observer = new IntersectionObserver((entries) => {\n      for (const entry of entries) {\n        if (entry.isIntersecting) {\n          callback()\n\n          if (once.has(el)) {\n            observer.disconnect()\n          }\n        }\n      }\n    }, options)\n\n    observer.observe(el)\n\n    if (mods.has('once')) {\n      once.add(el)\n    }\n\n    return () => {\n      if (!mods.has('once')) {\n        once.delete(el)\n      }\n      observer.disconnect()\n    }\n  },\n}\n", "// Authors: Ben Croker\n// Icon: material-symbols:timer-outline\n// Slug: Runs an expression on an interval\n// Description: This attribute runs an expression on an interval. The interval can be set to a specific duration, and can be set to trigger immediately.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../engine/types'\nimport { tagHas, tagToMs } from '../../../utils/tags'\nimport { modifyViewTransition } from '../../../utils/view-transtions'\n\nexport const OnInterval: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'onInterval',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: ({ mods, genRX, evalRX }) => {\n    const { dm, deps, rxFn } = genRX()\n    let callback = () => evalRX(rxFn, dm, deps)\n    callback = modifyViewTransition(callback, mods)\n\n    let duration = 1000\n    const durationArgs = mods.get('duration')\n    if (durationArgs) {\n      duration = tagToMs(durationArgs)\n      const leading = tagHas(durationArgs, 'leading', false)\n      if (leading) {\n        callback()\n      }\n    }\n\n    const intervalId = setInterval(callback, duration)\n\n    return () => {\n      clearInterval(intervalId)\n    }\n  },\n}\n", "// Authors: Ben Croker\n// Icon: material-symbols:timer-play-outline\n// Slug: Runs an expression when the element is loaded\n// Description: This attribute runs an expression when the element is loaded.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../engine/types'\nimport { tagToMs } from '../../../utils/tags'\nimport { modifyViewTransition } from '../../../utils/view-transtions'\nimport { delay } from '../../../utils/timing'\n\nconst once = new WeakSet<HTMLOrSVGElement>()\n\nexport const OnLoad: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'onLoad',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: ({ el, mods, genRX, evalRX }) => {\n    const { dm, deps, rxFn } = genRX()\n    let callback = () => evalRX(rxFn, dm, deps)\n    callback = modifyViewTransition(callback, mods)\n\n    let wait = 0\n    const delayArgs = mods.get('delay')\n    if (delayArgs) {\n      wait = tagToMs(delayArgs)\n    }\n\n    // Delay the callback regardless of whether the modifier is set so that other plugins are processed first.\n    callback = delay(callback, wait)\n\n    if (!once.has(el)) {\n      callback()\n    }\n\n    if (mods.has('once')) {\n      once.add(el)\n    }\n\n    return () => {\n      if (!mods.has('once')) {\n        once.delete(el)\n      }\n    }\n  },\n}\n", "import { DSS } from '../engine/consts'\nimport { depPaths } from '../engine/signals'\nimport { trimDollarSignPrefix } from './text'\n\nexport function pathMatchesPattern(path: string, pattern: string) {\n  // Do a little dance to correctly replace the double astersik\n  pattern = pattern\n    .replaceAll('.', '\\\\.')\n    .replaceAll('**', DSS)\n    .replaceAll('*', '[^\\\\.]*')\n    .replaceAll(DSS, '.*')\n  const regex = RegExp(`^${pattern}$`)\n\n  return regex.test(path)\n}\n\nexport function getMatchingDepPaths(paths: string) {\n  const matches = []\n  let patterns = paths.split(/\\s+/).filter((p) => p !== '')\n  patterns = patterns.map((p) => trimDollarSignPrefix(p))\n\n  for (const pattern of patterns) {\n    for (const depPath of depPaths()) {\n      if (pathMatchesPattern(depPath, pattern)) {\n        matches.push(depPath)\n      }\n    }\n  }\n\n  return matches\n}\n", "// Authors: Ben Croker\n// Icon: material-symbols:bigtop-updates\n// Slug: Runs an expression whenever a signal changes\n// Description: This attribute runs an expression whenever a signal changes.\n\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_EVENT,\n  type DatastarSignalEvent,\n  PluginType,\n  Requirement,\n} from '../../../engine/types'\nimport { modifyCasing } from '../../../utils/text'\nimport { modifyTiming } from '../../../utils/timing'\nimport { pathMatchesPattern } from '../../../utils/paths'\nimport { modifyViewTransition } from '../../../utils/view-transtions'\n\nexport const OnSignalChange: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'onSignalChange',\n  valReq: Requirement.Must,\n  argNames: ['evt'],\n  onLoad: ({ key, mods, genRX, evalRX }) => {\n    const { dm, deps, rxFn } = genRX()\n    let callback = (evt: Event) => evalRX(rxFn, dm, deps, evt)\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n\n    const signalFn = (event: CustomEvent<DatastarSignalEvent>) => {\n      if (key !== '') {\n        const pattern = modifyCasing(key, mods)\n        const { added, removed, updated } = event.detail\n        if (\n          ![...added, ...removed, ...updated].some((path) =>\n            pathMatchesPattern(path, pattern),\n          )\n        ) {\n          return\n        }\n      }\n      callback(event)\n    }\n\n    document.addEventListener(DATASTAR_SIGNAL_EVENT, signalFn)\n\n    return () => {\n      document.removeEventListener(DATASTAR_SIGNAL_EVENT, signalFn)\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi:cursor-pointer\n// Slug: Create a reference to an element\n// Description: This attribute creates a reference to an element that can be used in other expressions.\n\nimport { setDepValue } from '../../../engine/signals'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../engine/types'\nimport { modifyCasing, trimDollarSignPrefix } from '../../../utils/text'\n\n// Sets the value of the element\nexport const Ref: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'ref',\n  keyReq: Requirement.Exclusive,\n  valReq: Requirement.Exclusive,\n  onLoad: ({ el, key, mods, value, batch }) => {\n    const signalName = key\n      ? modifyCasing(key, mods)\n      : trimDollarSignPrefix(value)\n    batch(() => {\n      setDepValue(signalName, el)\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Show or hide an element\n// Description: This attribute shows or hides an element based on the value of the expression. If the expression is true, the element is shown. If the expression is false, the element is hidden. The element is hidden by setting the display property to none.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../engine/types'\n\nconst NONE = 'none'\nconst DISPLAY = 'display'\n\nexport const Show: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'show',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: ({ el: { style: s }, genRX, computed, effect }) => {\n    const { deps, rxFn } = genRX()\n    const c = computed<boolean>(deps, rxFn)\n    return effect([c], async (shouldShow: boolean) => {\n      if (shouldShow) {\n        if (s.display === NONE) {\n          s.removeProperty(DISPLAY)\n        }\n      } else {\n        s.setProperty(DISPLAY, NONE)\n      }\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: tabler:typography\n// Slug: Set the text content of an element\n// Description: This attribute sets the text content of an element to the result of the expression.\n\nimport { runtimeErr } from '../../../engine/errors'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../engine/types'\n\nexport const Text: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'text',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: (ctx) => {\n    const { el, genRX, computed, effect } = ctx\n    const { deps, rxFn } = genRX()\n    if (!(el instanceof HTMLElement)) {\n      runtimeErr('TextInvalidElement', ctx)\n    }\n    const c = computed(deps, rxFn)\n    return effect([c], (res) => {\n      el.textContent = `${res}`\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: ion:checkmark-round\n// Slug: Set all signals that match the signal path\n// Description: Set all signals that match one or more space-separated paths in which `*` can be used as a wildcard\n\nimport { setDepValue } from '../../../engine/signals'\nimport { type ActionPlugin, PluginType } from '../../../engine/types'\nimport { getMatchingDepPaths } from '../../../utils/paths'\n\nexport const SetAll: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'setAll',\n  fn: ({ batch }, paths: string, newValue) => {\n    batch(() => {\n      const depPaths = getMatchingDepPaths(paths)\n      for (const depPath of depPaths) {\n        setDepValue(depPath, newValue)\n      }\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:toggle-off\n// Slug: Toggle all signals that match the signal path\n// Description: Toggle all signals that match one or more space-separated paths in which `*` can be used as a wildcard\n\nimport { depValue, setDepValue } from '../../../engine/signals'\nimport { type ActionPlugin, PluginType } from '../../../engine/types'\nimport { getMatchingDepPaths } from '../../../utils/paths'\n\nexport const ToggleAll: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'toggleAll',\n  fn: ({ batch }, paths: string) => {\n    batch(() => {\n      const depPaths = getMatchingDepPaths(paths)\n      for (const depPath of depPaths) {\n        setDepValue(depPath, !depValue(depPath))\n      }\n    })\n  },\n}\n", "import { apply, load, setAlias } from '../engine'\nimport { DELETE } from '../plugins/framework/backend/actions/delete'\nimport { GET } from '../plugins/framework/backend/actions/get'\nimport { PATCH } from '../plugins/framework/backend/actions/patch'\nimport { POST } from '../plugins/framework/backend/actions/post'\nimport { PUT } from '../plugins/framework/backend/actions/put'\nimport { ExecuteScript } from '../plugins/framework/backend/watchers/executeScript'\nimport { MergeFragments } from '../plugins/framework/backend/watchers/mergeFragments'\nimport { MergeSignals } from '../plugins/framework/backend/watchers/mergeSignals'\nimport { RemoveFragments } from '../plugins/framework/backend/watchers/removeFragments'\nimport { RemoveSignals } from '../plugins/framework/backend/watchers/removeSignals'\nimport { Attr } from '../plugins/framework/attributes/attr'\nimport { Bind } from '../plugins/framework/attributes/bind'\nimport { Class } from '../plugins/framework/attributes/class'\nimport { Indicator } from '../plugins/framework/attributes/indicator'\nimport { JsonSignals } from '../plugins/framework/attributes/jsonSignals'\nimport { On } from '../plugins/framework/attributes/on'\nimport { OnIntersect } from '../plugins/framework/attributes/onIntersect'\nimport { OnInterval } from '../plugins/framework/attributes/onInterval'\nimport { OnLoad } from '../plugins/framework/attributes/onLoad'\nimport { OnSignalChange } from '../plugins/framework/attributes/onSignalChange'\nimport { Ref } from '../plugins/framework/attributes/ref'\nimport { Show } from '../plugins/framework/attributes/show'\nimport { Text } from '../plugins/framework/attributes/text'\nimport { SetAll } from '../plugins/framework/actions/setAll'\nimport { ToggleAll } from '../plugins/framework/actions/toggleAll'\n\nload(\n  // Backend\n  GET,\n  POST,\n  PUT,\n  PATCH,\n  DELETE,\n  MergeFragments,\n  MergeSignals,\n  RemoveFragments,\n  RemoveSignals,\n  ExecuteScript,\n  // Attributes\n  Attr,\n  Bind,\n  Class,\n  Indicator,\n  JsonSignals,\n  On,\n  OnIntersect,\n  OnInterval,\n  OnLoad,\n  OnSignalChange,\n  Ref,\n  Show,\n  Text,\n  // Actions\n  SetAll,\n  ToggleAll,\n)\n\napply()\n\nexport { apply, load, setAlias }\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "DATASTAR_REQUEST", "DefaultSseRetryDurationMs", "DefaultExecuteScriptAttributes", "DefaultFragmentsUseViewTransitions", "DefaultMergeSignalsOnlyIfMissing", "DefaultExecuteScriptAutoRemove", "FragmentMergeModeMorph", "FragmentMergeModeInner", "FragmentMergeModeOuter", "FragmentMergeModePrepend", "FragmentMergeModeAppend", "FragmentMergeModeBefore", "FragmentMergeModeAfter", "FragmentMergeModeUpsertAttributes", "DefaultFragmentMergeMode", "EventTypeMergeFragments", "EventTypeMergeSignals", "EventTypeRemoveFragments", "EventTypeRemoveSignals", "EventTypeExecuteScript", "PluginType", "DATASTAR_SIGNAL_EVENT", "DATASTAR", "isBoolString", "str", "kebab", "camel", "x", "snake", "pascal", "jsStrToObject", "raw", "trimDollarSignPrefix", "caseFns", "modifyCasing", "mods", "c", "fn", "name", "Computed", "key", "mods", "genRX", "computed", "batch", "modifyCasing", "deps", "rxFn", "added", "removed", "updated", "batch", "fn", "result", "DATASTAR_SIGNAL_EVENT", "dependencyPaths", "dependencies", "depPaths", "dep", "path", "depRange", "prefix", "results", "left", "right", "predicate", "s", "mid", "midPath", "start", "end", "i", "setDep", "removeDeps", "setDepValue", "value", "existingSignal", "Signal", "signal", "depValue", "upsertIfMissing", "defaultValue", "inserted", "mergeDeps", "toMerge", "onlyIfMissing", "flattened", "flatten", "paths", "subPaths", "subPath", "index", "json", "shouldIndent", "onlyPublic", "nested", "filtered", "found", "unflatten", "isPlainObject", "obj", "roots", "sep", "memo", "prop", "key", "keys", "current", "k", "evalRX", "rxFn", "dm", "deps", "args", "args", "notifyBuffer", "notifyIndex", "notifyBufferLength", "getter", "deps", "fn", "len", "i", "updateComputed", "computed", "oldValue", "newValue", "notifyEffect", "effect", "flags", "updateDirtyFlag", "sub", "checkDirty", "signal", "value", "path", "Signal", "currentValue", "setDep", "updated", "current", "next", "branchs", "branchDepth", "targetFlag", "top", "subFlags", "shouldNotify", "isValidLink", "subSubs", "Computed", "dep", "link", "subs", "shallowPropagate", "e", "Effect", "nextDep", "nextSub", "prevSub", "depFlags", "depDeps", "currentDep", "depLastSub", "newLink", "oldTail", "prevLinks", "checkDepth", "dirty", "firstSub", "checkLink", "depsTail", "Signals", "ctx", "key", "mods", "value", "genRX", "evalRX", "batch", "deps", "dm", "rxFn", "ifMissing", "k", "modifyCasing", "v", "upsertIfMissing", "setDepValue", "nv", "mergeDeps", "isHTMLOrSVG", "el", "walkDOM", "element", "callback", "iter", "dataset", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "r", "snake", "q", "c", "initErr", "reason", "ctx", "metadata", "errCtx", "PluginType", "dserr", "runtimeErr", "depPaths", "actions", "plugins", "removals", "mutationObserver", "alias", "setAlias", "value", "load", "pluginsToLoad", "plugin", "ctx", "applyToElement", "batch", "signal", "computed", "effect", "type", "initErr", "a", "b", "lenDiff", "apply", "walkDOM", "observe", "mutations", "target", "addedNodes", "removedNodes", "node", "el", "elCleanups", "cleanup", "djb2", "str", "hash", "i", "toApply", "toCleanup", "key", "applyAttributePlugin", "datasetKey", "rawKey", "camel", "p", "rawModifiers", "hasKey", "hasValue", "genRX", "evalRX", "keyReq", "runtimeErr", "valReq", "rawMod", "label", "mod", "t", "argNames", "dm", "dependencySet", "expr", "statementRe", "statements", "lastIdx", "last", "escaped", "escapeRe", "DSP", "DSS", "match", "k", "v", "nameGen", "prefix", "name", "snake", "argsDependenciesActionsNames", "dependencyPaths", "depPaths", "pattern", "signalsWithAssignedValuesRe", "signalsWithAssignedValuesMatches", "updateUserExpression", "suffix", "signalMutationPrefix", "DATASTAR", "mutableDependencies", "depName", "d", "dep", "pureDependencyRe", "allPureDependenciesMatches", "pureDependencyPrefix", "pureDependencies", "pureDepName", "pureDep", "actionsCalled", "actionsRe", "actionMatches", "actionFns", "actionPrefix", "actionName", "action", "args", "fn", "argsAndDependencyValues", "e", "error", "load", "Signals", "Computed", "DATASTAR_SSE_EVENT", "DATASTAR", "STARTED", "FINISHED", "ERROR", "RETRYING", "RETRIES_FAILED", "datastarSSEEventWatcher", "eventType", "fn", "event", "argsRaw", "dispatchSSE", "type", "el", "argsRaw", "DATASTAR_SSE_EVENT", "isWrongContent", "err", "shouldSendUsingQueryParams", "method", "sse", "ctx", "url", "args", "evt", "userHeaders", "contentType", "includeLocal", "excludeSignals", "selector", "openWhenHidden", "retryInterval", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "abort", "DefaultSseRetryDurationMs", "action", "cleanupFn", "runtimeErr", "initialHeaders", "DATASTAR_REQUEST", "headers", "req", "response", "status", "ERROR", "DATASTAR", "argsRawLines", "lines", "line", "colonIndex", "key", "argLines", "value", "error", "RETRYING", "urlInstance", "queryParams", "res", "json", "formEl", "formData", "submitter", "preventDefault", "name", "multipart", "formParams", "STARTED", "fetchEventSource", "FINISHED", "getBytes", "stream", "onChunk", "reader", "result", "getLines", "onLine", "buffer", "position", "fieldLength", "discardTrailingNewline", "arr", "concat", "bufLength", "lineStart", "lineEnd", "getMessages", "onId", "onRetry", "onMessage", "message", "newMessage", "decoder", "line", "field", "valueOffset", "value", "retry", "a", "b", "res", "EventStreamContentType", "LastEventId", "fetchEventSource", "input", "el", "inputSignal", "inputHeaders", "inputOnOpen", "onmessage", "onclose", "onerror", "openWhenHidden", "inputFetch", "retryInterval", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "rest", "resolve", "reject", "retries", "headers", "curRequestController", "onVisibilityChange", "create", "retryTimer", "dispose", "fetch", "onopen", "response", "getBytes", "id", "err", "interval", "dispatchSSE", "RETRIES_FAILED", "innerErr", "DELETE", "ctx", "url", "args", "sse", "GET", "ctx", "url", "args", "sse", "PATCH", "ctx", "url", "args", "sse", "POST", "ctx", "url", "args", "sse", "PUT", "ctx", "url", "args", "sse", "ExecuteScript", "EventTypeExecuteScript", "ctx", "datastarSSEEventWatcher", "autoRemoveRaw", "DefaultExecuteScriptAutoRemove", "attributesRaw", "DefaultExecuteScriptAttributes", "script", "autoRemove", "isBoolString", "initErr", "scriptEl", "attr", "pivot", "key", "value", "docWithViewTransitionAPI", "supportsViewTransitions", "modifyViewTransition", "callback", "mods", "cb", "args", "DIV", "VALUE", "createEl", "tagName", "createDiv", "tagRaw", "elIDs", "el", "isElement", "isTemplate", "isInput", "isTextArea", "isOption", "MergeFragments", "EventTypeMergeFragments", "ctx", "fragmentContainer", "datastarSSEEventWatcher", "fragmentsRaw", "selector", "mergeMode", "DefaultFragmentMergeMode", "useViewTransitionRaw", "useViewTransition", "isBoolString", "fragment", "initErr", "selectorOrID", "targets", "supportsViewTransitions", "docWithViewTransitionAPI", "applyToTargets", "capturedTargets", "target", "fragmentToMerge", "FragmentMergeModeMorph", "morph", "walkDOM", "cleanups", "cleanup", "FragmentMergeModeInner", "FragmentMergeModeOuter", "FragmentMergeModePrepend", "FragmentMergeModeAppend", "FragmentMergeModeBefore", "FragmentMergeModeAfter", "FragmentMergeModeUpsertAttributes", "attrName", "value", "ctxPantry", "ctxTarget", "ctxIdMap", "ctxPersistentIds", "moveBeforeSupported", "oldNode", "newContent", "normalizedNode", "newIdElements", "oldIdElements", "duplicateIds", "oldIdTagNameMap", "id", "populateIdMapWithTree", "oldParent", "beforeStartPoint", "endPoint", "morphChildren", "nodes", "cursor", "newParent", "insertionPoint", "newChild", "bestMatch", "findBestMatch", "tempNode", "removeNode", "morphNode", "ncID", "qsTemplate", "qs", "movedChild", "current", "idSet", "moveBefore", "newEmptyChild", "insertedNode", "node", "startPoint", "nextSibling", "siblingSoftMatchCount", "displaceMatchCount", "nodeMatchCount", "isSoftMatch", "isIdSetMatch", "oldSet", "newSet", "newNode", "oldElt", "newElt", "parentNode", "element", "after", "type", "oldAttributes", "newAttributes", "newAttribute", "i", "oldAttribute", "newValue", "oldValue", "syncBooleanAttribute", "key", "writeTo", "readFrom", "attributeName", "readFromAny", "writeToAny", "newLiveValue", "oldLiveValue", "root", "elements", "elt", "MergeSignals", "EventTypeMergeSignals", "batch", "datastarSSEEventWatcher", "raw", "onlyIfMissingRaw", "DefaultMergeSignalsOnlyIfMissing", "onlyIfMissing", "isBoolString", "rawObj", "jsStrToObject", "mergeDeps", "RemoveFragments", "EventTypeRemoveFragments", "ctx", "datastarSSEEventWatcher", "selector", "useViewTransitionRaw", "DefaultFragmentsUseViewTransitions", "initErr", "useViewTransition", "isBoolString", "removeTargets", "applyToTargets", "target", "supportsViewTransitions", "docWithViewTransitionAPI", "RemoveSignals", "EventTypeRemoveSignals", "ctx", "batch", "datastarSSEEventWatcher", "pathsRaw", "paths", "p", "initErr", "removeDeps", "Attr", "el", "key", "genRX", "computed", "effect", "deps", "rxFn", "c", "binds", "val", "kebab", "value", "v", "dataURIRegex", "updateEvents", "Bind", "ctx", "el", "key", "mods", "value", "effect", "batch", "input", "signalName", "modifyCasing", "trimDollarSignPrefix", "tnl", "isInput", "isSelect", "type", "hasValueAttribute", "signalDefault", "isCheckbox", "isNumber", "isRadio", "isFile", "dep", "inserted", "upsertIfMissing", "arrayIndex", "isArray", "signalArray", "depValue", "setElementFromSignal", "stringValue", "select", "runtimeErr", "opt", "incoming", "setSignalFromElement", "currentValue", "currentArray", "update", "newValue", "setDepValue", "files", "allContents", "allMimes", "allNames", "f", "resolve", "reader", "match", "checked", "selectedOptions", "event", "onPageshow", "ev", "reset", "Class", "el", "key", "mods", "genRX", "computed", "effect", "cl", "deps", "rxFn", "value", "classes", "k", "v", "classNames", "className", "kebab", "modifyCasing", "Indicator", "ctx", "el", "key", "mods", "value", "batch", "signalName", "modifyCasing", "trimDollarSignPrefix", "dep", "upsertIfMissing", "Signal", "runtimeErr", "watcher", "event", "type", "elt", "STARTED", "FINISHED", "DATASTAR_SSE_EVENT", "JsonSignals", "ctx", "el", "runtimeErr", "callback", "json", "DATASTAR_SIGNAL_EVENT", "tagToMs", "args", "arg", "tagHas", "tags", "tag", "defaultValue", "delay", "callback", "wait", "args", "debounce", "leading", "trailing", "timer", "resetTimer", "throttle", "waiting", "modifyTiming", "mods", "delayArgs", "tagToMs", "debounceArgs", "tagHas", "throttleArgs", "On", "ctx", "el", "key", "mods", "genRX", "evalRX", "target", "dm", "deps", "rxFn", "callback", "evt", "modifyTiming", "modifyViewTransition", "evtListOpts", "cb", "targetHTML", "eventName", "kebab", "modifyCasing", "DATASTAR_SSE_EVENT", "once", "OnIntersect", "el", "mods", "genRX", "evalRX", "dm", "deps", "rxFn", "callback", "modifyTiming", "modifyViewTransition", "options", "observer", "entries", "entry", "OnInterval", "mods", "genRX", "evalRX", "dm", "deps", "rxFn", "callback", "modifyViewTransition", "duration", "durationArgs", "tagToMs", "tagHas", "intervalId", "once", "OnLoad", "el", "mods", "genRX", "evalRX", "dm", "deps", "rxFn", "callback", "modifyViewTransition", "wait", "delayArgs", "tagToMs", "delay", "pathMatchesPattern", "path", "pattern", "DSS", "getMatchingDepPaths", "paths", "matches", "patterns", "p", "trimDollarSignPrefix", "depPath", "depPaths", "OnSignalChange", "key", "mods", "genRX", "evalRX", "dm", "deps", "rxFn", "callback", "evt", "modifyTiming", "modifyViewTransition", "signalFn", "event", "pattern", "modifyCasing", "added", "removed", "updated", "path", "pathMatchesPattern", "DATASTAR_SIGNAL_EVENT", "Ref", "el", "key", "mods", "value", "batch", "signalName", "modifyCasing", "trimDollarSignPrefix", "setDepValue", "NONE", "DISPLAY", "Show", "s", "genRX", "computed", "effect", "deps", "rxFn", "c", "shouldShow", "Text", "ctx", "el", "genRX", "computed", "effect", "deps", "rxFn", "runtimeErr", "c", "res", "SetAll", "batch", "paths", "newValue", "depPaths", "getMatchingDepPaths", "depPath", "setDepValue", "ToggleAll", "batch", "paths", "depPaths", "getMatchingDepPaths", "depPath", "setDepValue", "depValue", "load", "GET", "POST", "PUT", "PATCH", "DELETE", "MergeFragments", "MergeSignals", "RemoveFragments", "RemoveSignals", "ExecuteScript", "Attr", "Bind", "Class", "Indicator", "JsonSignals", "On", "OnIntersect", "OnInterval", "OnLoad", "OnSignalChange", "Ref", "Show", "Text", "SetAll", "ToggleAll", "apply"]
}
